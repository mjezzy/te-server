import { DataFactory } from 'n3';
export { DataFactory } from 'n3';
import { freeze, getBlankNodeId, isBlankNodeId, getBlankNodeValue } from './rdf.internal.mjs';
import { xmlSchemaTypes } from './datatypes.mjs';

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
function addRdfJsQuadToDataset(dataset, quad) {
    var _a;
    const supportedGraphTypes = [
        "NamedNode",
        "DefaultGraph",
    ];
    if (!supportedGraphTypes.includes(quad.graph.termType)) {
        throw new Error(`Cannot parse Quads with nodes of type [${quad.graph.termType}] as their Graph node.`);
    }
    const graphId = quad.graph.termType === "DefaultGraph" ? "default" : quad.graph.value;
    const graph = (_a = dataset.graphs[graphId]) !== null && _a !== void 0 ? _a : {};
    return freeze({
        ...dataset,
        graphs: freeze({
            ...dataset.graphs,
            [graphId]: addRdfJsQuadToGraph(graph, quad),
        }),
    });
}
function addRdfJsQuadToGraph(graph, quad) {
    var _a;
    const supportedSubjectTypes = [
        "NamedNode",
        "BlankNode",
    ];
    if (!supportedSubjectTypes.includes(quad.subject.termType)) {
        throw new Error(`Cannot parse Quads with nodes of type [${quad.subject.termType}] as their Subject node.`);
    }
    const subjectIri = quad.subject.termType === "BlankNode"
        ? `_:${quad.subject.value}`
        : quad.subject.value;
    const subject = (_a = graph[subjectIri]) !== null && _a !== void 0 ? _a : {
        type: "Subject",
        url: subjectIri,
        predicates: {},
    };
    return freeze({
        ...graph,
        [subjectIri]: addRdfJsQuadToSubject(subject, quad),
    });
}
function addRdfJsQuadToSubject(subject, quad) {
    return freeze({
        ...subject,
        predicates: addRdfJsQuadToPredicates(subject.predicates, quad),
    });
}
function addRdfJsQuadToPredicates(predicates, quad) {
    var _a;
    const supportedPredicateTypes = [
        "NamedNode",
    ];
    if (!supportedPredicateTypes.includes(quad.predicate.termType)) {
        throw new Error(`Cannot parse Quads with nodes of type [${quad.predicate.termType}] as their Predicate node.`);
    }
    const predicateIri = quad.predicate.value;
    const objects = (_a = predicates[predicateIri]) !== null && _a !== void 0 ? _a : {};
    return freeze({
        ...predicates,
        [predicateIri]: addRdfJsQuadToObjects(objects, quad),
    });
}
function addRdfJsQuadToObjects(objects, quad) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (quad.object.termType === "NamedNode") {
        const namedNodes = freeze([
            ...((_a = objects.namedNodes) !== null && _a !== void 0 ? _a : []),
            quad.object.value,
        ]);
        return freeze({
            ...objects,
            namedNodes,
        });
    }
    if (quad.object.termType === "Literal") {
        if (quad.object.datatype.value === xmlSchemaTypes.langString) {
            const locale = quad.object.language.toLowerCase();
            const thisLocaleStrings = freeze([
                ...((_c = (_b = objects.langStrings) === null || _b === void 0 ? void 0 : _b[locale]) !== null && _c !== void 0 ? _c : []),
                quad.object.value,
            ]);
            const langStrings = freeze({
                ...((_d = objects.langStrings) !== null && _d !== void 0 ? _d : {}),
                [locale]: thisLocaleStrings,
            });
            return freeze({
                ...objects,
                langStrings,
            });
        }
        // If the Object is a non-langString Literal
        const thisTypeValues = freeze([
            ...((_f = (_e = objects.literals) === null || _e === void 0 ? void 0 : _e[quad.object.datatype.value]) !== null && _f !== void 0 ? _f : []),
            quad.object.value,
        ]);
        const literals = freeze({
            ...((_g = objects.literals) !== null && _g !== void 0 ? _g : {}),
            [quad.object.datatype.value]: thisTypeValues,
        });
        return freeze({
            ...objects,
            literals,
        });
    }
    if (quad.object.termType === "BlankNode") {
        const blankNodes = freeze([
            ...((_h = objects.blankNodes) !== null && _h !== void 0 ? _h : []),
            getBlankNodeId(quad.object),
        ]);
        return freeze({
            ...objects,
            blankNodes,
        });
    }
    throw new Error(`Objects of type [${quad.object.termType}] are not supported.`);
}
function toRdfJsQuads(dataset, options = {}) {
    var _a;
    const quads = [];
    const dataFactory = (_a = options.dataFactory) !== null && _a !== void 0 ? _a : DataFactory;
    Object.keys(dataset.graphs).forEach((graphIri) => {
        const graph = dataset.graphs[graphIri];
        const graphNode = graphIri === "default"
            ? dataFactory.defaultGraph()
            : dataFactory.namedNode(graphIri);
        Object.keys(graph).forEach((subjectIri) => {
            const { predicates } = graph[subjectIri];
            const subjectNode = isBlankNodeId(subjectIri)
                ? dataFactory.blankNode(getBlankNodeValue(subjectIri))
                : dataFactory.namedNode(subjectIri);
            quads.push(...subjectToRdfJsQuads(predicates, subjectNode, graphNode, options));
        });
    });
    return quads;
}
function subjectToRdfJsQuads(predicates, subjectNode, graphNode, options = {}) {
    var _a;
    const quads = [];
    const dataFactory = (_a = options.dataFactory) !== null && _a !== void 0 ? _a : DataFactory;
    Object.keys(predicates).forEach((predicateIri) => {
        var _a, _b, _c, _d;
        const predicateNode = dataFactory.namedNode(predicateIri);
        const langStrings = (_a = predicates[predicateIri].langStrings) !== null && _a !== void 0 ? _a : {};
        const namedNodes = (_b = predicates[predicateIri].namedNodes) !== null && _b !== void 0 ? _b : [];
        const literals = (_c = predicates[predicateIri].literals) !== null && _c !== void 0 ? _c : {};
        const blankNodes = (_d = predicates[predicateIri].blankNodes) !== null && _d !== void 0 ? _d : [];
        const literalTypes = Object.keys(literals);
        literalTypes.forEach((typeIri) => {
            const typeNode = dataFactory.namedNode(typeIri);
            const literalValues = literals[typeIri];
            literalValues.forEach((value) => {
                const literalNode = dataFactory.literal(value, typeNode);
                quads.push(dataFactory.quad(subjectNode, predicateNode, literalNode, graphNode));
            });
        });
        const locales = Object.keys(langStrings);
        locales.forEach((locale) => {
            const localeValues = langStrings[locale];
            localeValues.forEach((value) => {
                const langStringNode = dataFactory.literal(value, locale);
                quads.push(dataFactory.quad(subjectNode, predicateNode, langStringNode, graphNode));
            });
        });
        namedNodes.forEach((namedNodeIri) => {
            const node = dataFactory.namedNode(namedNodeIri);
            quads.push(dataFactory.quad(subjectNode, predicateNode, node, graphNode));
        });
        blankNodes.forEach((blankNodeIdOrPredicates) => {
            if (isBlankNodeId(blankNodeIdOrPredicates)) {
                const blankNode = dataFactory.blankNode(getBlankNodeValue(blankNodeIdOrPredicates));
                quads.push(dataFactory.quad(subjectNode, predicateNode, blankNode, graphNode));
            }
            else {
                const node = dataFactory.blankNode();
                const blankNodeObjectQuad = dataFactory.quad(subjectNode, predicateNode, node, graphNode);
                const blankNodeSubjectQuads = subjectToRdfJsQuads(blankNodeIdOrPredicates, node, graphNode);
                quads.push(blankNodeObjectQuad);
                quads.push(...blankNodeSubjectQuads);
            }
        });
    });
    return quads;
}

export { addRdfJsQuadToDataset, subjectToRdfJsQuads, toRdfJsQuads };
