import { issueVerifiableCredential } from '@inrupt/solid-client-vc';
import { CONTEXT_VC_W3C, CREDENTIAL_TYPE_ACCESS_GRANT, CREDENTIAL_TYPE_ACCESS_REQUEST } from '../constants.mjs';
import { buildProviderContext, DEFAULT_CONTEXT } from '../../common/providerConfig.mjs';
import { getSessionFetch } from '../../common/util/getSessionFetch.mjs';
import { getAccessApiEndpoint } from '../discover/getAccessApiEndpoint.mjs';
import { accessToResourceAccessModeArray } from './accessToResourceAccessModeArray.mjs';
import { isBaseRequest } from '../guard/isBaseRequest.mjs';
import { AccessGrantError } from '../../common/errors/AccessGrantError.mjs';

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
function getGConsentAttributes(params, type) {
    const modes = accessToResourceAccessModeArray(params.access);
    const consentAttributes = {
        mode: modes,
        hasStatus: params.status,
        forPersonalData: params.resources,
    };
    if (params.purpose !== undefined) {
        consentAttributes.forPurpose = params.purpose;
    }
    if (params.inherit !== undefined) {
        consentAttributes.inherit = params.inherit;
    }
    if (type === "BaseGrantBody") {
        return {
            ...consentAttributes,
            isProvidedTo: params.requestor,
        };
    }
    return {
        ...consentAttributes,
        isConsentForDataSubject: params.resourceOwner,
    };
}
function getBaseBody(params, type) {
    const body = {
        "@context": [CONTEXT_VC_W3C, DEFAULT_CONTEXT],
        type: [
            type === "BaseGrantBody"
                ? CREDENTIAL_TYPE_ACCESS_GRANT
                : CREDENTIAL_TYPE_ACCESS_REQUEST,
        ],
        credentialSubject: {
            inbox: params.requestorInboxUrl,
        },
    };
    if (params.issuanceDate !== undefined) {
        body.issuanceDate = params.issuanceDate.toISOString();
    }
    if (params.expirationDate !== undefined) {
        body.expirationDate =
            params.expirationDate.toISOString();
    }
    if (type === "BaseGrantBody") {
        return {
            ...body,
            credentialSubject: {
                ...body.credentialSubject,
                providedConsent: getGConsentAttributes(params, type),
            },
        };
    }
    return {
        ...body,
        credentialSubject: {
            ...body.credentialSubject,
            hasConsent: getGConsentAttributes(params, type),
        },
    };
}
function getRequestBody(params, options) {
    const base = getBaseBody(params, "BaseRequestBody");
    if (typeof options?.customFields === "object") {
        Object.assign(base.credentialSubject.hasConsent, options.customFields);
    }
    return base;
}
function getGrantBody(params, options) {
    const base = getBaseBody(params, "BaseGrantBody");
    if (typeof options?.customFields === "object") {
        Object.assign(base.credentialSubject.providedConsent, options.customFields);
    }
    return base;
}
async function issueAccessVc(vcBody, options = {}) {
    const fetcher = await getSessionFetch(options);
    const hasConsent = isBaseRequest(vcBody);
    if (hasConsent &&
        vcBody.credentialSubject.hasConsent.forPersonalData.length <= 0) {
        throw new AccessGrantError("There are no resources in the access request");
    }
    else if (!hasConsent &&
        vcBody.credentialSubject.providedConsent.forPersonalData
            .length <= 0) {
        throw new AccessGrantError("There are no resources in the access grant");
    }
    const targetResourceIri = isBaseRequest(vcBody)
        ? vcBody.credentialSubject.hasConsent.forPersonalData[0]
        : vcBody.credentialSubject.providedConsent
            .forPersonalData[0];
    // TODO: find out if concatenating "issue" here is correct
    // It seems like the issuer endpoint should be discovered from the well-known direcly
    // And the access endpoint should be an object with one URI per service
    // (issuer service, verifier service... supposedly status and query and vc???)
    const provider = new URL(await getAccessApiEndpoint(targetResourceIri, options));
    const accessIssuerEndpoint = new URL("issue", provider);
    const issuedVc = await issueVerifiableCredential(accessIssuerEndpoint.href, {
        "@context": await buildProviderContext(provider),
        ...vcBody.credentialSubject,
    }, {
        // All the required context is provided by buildProviderContext,
        // and vcBody contains a default context we don't want to include in the
        // result VC.
        "@context": [],
        type: vcBody.type,
        issuanceDate: vcBody.issuanceDate,
        expirationDate: vcBody.expirationDate,
    }, {
        fetch: fetcher,
        returnLegacyJsonld: options.returnLegacyJsonld,
        normalize: options.normalize,
    });
    return issuedVc;
}

export { getGrantBody, getRequestBody, issueAccessVc };
