import { getCredentialSubject, getId } from '@inrupt/solid-client-vc';
export { getCredentialSubject, getExpirationDate, getId, getIssuanceDate, getIssuer } from '@inrupt/solid-client-vc';
import { DataFactory } from 'n3';
import { gc, ldp, acl, TYPE, INHERIT, XSD_BOOLEAN } from './constants.mjs';
import { AccessGrantError } from './errors/AccessGrantError.mjs';

const { namedNode, defaultGraph, quad, literal } = DataFactory;
function getSingleObject(vc, subject, predicate, type, required = true) {
    const results = [...vc.match(subject, predicate, null, defaultGraph())];
    if (results.length === 0 && !required) {
        return undefined;
    }
    if (results.length !== 1) {
        throw new AccessGrantError(`Expected exactly one result. Found ${results.length}.`);
    }
    const [{ object }] = results;
    const expectedTypes = type ? [type] : ["NamedNode", "BlankNode"];
    if (!expectedTypes.includes(object.termType)) {
        throw new AccessGrantError(`Expected [${object.value}] to be a ${expectedTypes.join(" or ")}. Found [${object.termType}]`);
    }
    return object;
}
/**
 * @internal
 */
function getConsent(vc) {
    const credentialSubject = getCredentialSubject(vc);
    const consents = [
        ...vc.match(credentialSubject, gc.providedConsent, null, defaultGraph()),
        ...vc.match(credentialSubject, gc.hasConsent, null, defaultGraph()),
    ];
    if (consents.length !== 1) {
        throw new AccessGrantError(`Expected exactly 1 consent value. Found ${consents.length}.`);
    }
    const [{ object }] = consents;
    if (object.termType !== "BlankNode" && object.termType !== "NamedNode") {
        throw new AccessGrantError(`Expected consent to be a Named Node or Blank Node, instead got [${object.termType}].`);
    }
    return object;
}
/**
 * Get the resources to which an Access Grant/Request applies.
 *
 * @example
 *
 * ```
 * const resources = getResources(accessGrant);
 * ```
 *
 * @param vc The Access Grant/Request
 * @returns The resources IRIs
 */
function getResources(vc) {
    const resources = [];
    for (const { object } of vc.match(getConsent(vc), gc.forPersonalData, null, defaultGraph())) {
        if (object.termType !== "NamedNode") {
            throw new AccessGrantError(`Expected resource to be a Named Node. Instead got [${object.value}] with term type [${object.termType}]`);
        }
        resources.push(object.value);
    }
    return resources;
}
/**
 * Get the purposes for which an Access Grant/Request applies.
 *
 * @example
 *
 * ```
 * const purposes = getPurposes(accessGrant);
 * ```
 *
 * @param vc The Access Grant/Request
 * @returns The purpose IRIs
 */
function getPurposes(vc) {
    const consent = getConsent(vc);
    const purposes = [];
    for (const { object } of vc.match(consent, gc.forPurpose, null, defaultGraph())) {
        if (object.termType !== "NamedNode") {
            throw new AccessGrantError(`Expected purpose to be Named Node. Instead got [${object.value}] with term type [${object.termType}]`);
        }
        purposes.push(object.value);
    }
    return purposes;
}
function isGConsentAccessGrant(vc) {
    const credentialSubject = getCredentialSubject(vc);
    const providedConsent = getSingleObject(vc, credentialSubject, gc.providedConsent, undefined, false);
    if (!providedConsent)
        return false;
    const gcStatus = getSingleObject(vc, providedConsent, gc.hasStatus, undefined, false);
    return (gcStatus !== undefined &&
        (vc.has(quad(providedConsent, gc.hasStatus, gc.ConsentStatusDenied)) ||
            vc.has(quad(providedConsent, gc.hasStatus, gc.ConsentStatusExplicitlyGiven))) &&
        getSingleObject(vc, providedConsent, gc.isProvidedTo, undefined, false)
            ?.termType === "NamedNode");
}
function getResourceOwner(vc) {
    const credentialSubject = getCredentialSubject(vc);
    if (isGConsentAccessGrant(vc)) {
        return credentialSubject.value;
    }
    return getSingleObject(vc, getSingleObject(vc, credentialSubject, gc.hasConsent), gc.isConsentForDataSubject, "NamedNode", false)?.value;
}
/**
 * Get the requestor asking for access to a resources with an Access Grant/Request.
 *
 * @example
 *
 * ```
 * const requestorWebId = getRequestor(accessGrant);
 * ```
 *
 * @param vc The Access Grant/Request
 * @returns The requestor WebID
 */
function getRequestor(vc) {
    const credentialSubject = getCredentialSubject(vc);
    const providedConsent = getSingleObject(vc, credentialSubject, gc.providedConsent, undefined, false);
    if (!providedConsent)
        return credentialSubject.value;
    const supportedPredicates = [
        gc.isProvidedTo,
        gc.isProvidedToPerson,
        gc.isProvidedToController,
    ];
    const candidateResults = [];
    supportedPredicates.forEach((predicate) => {
        const candidate = getSingleObject(vc, providedConsent, predicate, "NamedNode", false);
        if (candidate !== undefined) {
            candidateResults.push(candidate.value);
        }
    });
    if (candidateResults.length === 1) {
        return candidateResults[0];
    }
    if (candidateResults.length > 1) {
        throw new AccessGrantError(`Too many requestors found. Expected one, found ${candidateResults}`);
    }
    throw new AccessGrantError(`No requestor found.`);
}
/**
 * Get the inbox of the requestor of an Access Grant/Request.
 *
 * @example
 *
 * ```
 * const inbox = getInbox(accessGrant);
 * ```
 *
 * @param vc The Access Grant/Request
 * @returns The requestors inbox
 */
function getInbox(vc) {
    try {
        return getSingleObject(vc, getCredentialSubject(vc), ldp.inbox, "NamedNode")
            .value;
    }
    catch {
        return undefined;
    }
}
/**
 * Get the access modes granted to a resources via an Access Grant/Request.
 *
 * @example
 *
 * ```
 * const modes = getAccessModes(accessGrant);
 * ```
 *
 * @param vc The Access Grant/Request
 * @returns The access modes the grant recipient can exercise.
 */
function getAccessModes(vc) {
    const consent = getConsent(vc);
    return {
        read: vc.has(quad(consent, acl.mode, acl.Read, defaultGraph())),
        write: vc.has(quad(consent, acl.mode, acl.Write, defaultGraph())),
        append: vc.has(quad(consent, acl.mode, acl.Append, defaultGraph())),
    };
}
const shorthand = {
    "http://www.w3.org/ns/solid/vc#SolidAccessRequest": "SolidAccessRequest",
    "http://www.w3.org/ns/solid/vc#SolidAccessDenial": "SolidAccessDenial",
    "http://www.w3.org/ns/solid/vc#SolidAccessGrant": "SolidAccessGrant",
    "https://www.w3.org/2018/credentials#VerifiableCredential": "VerifiableCredential",
    "https://www.w3.org/2018/credentials#VerifiablePresentation": "VerifiablePresentation",
};
/**
 * Get the VC types of an Access Grant/Request.
 *
 * @example
 *
 * ```
 * const types = getTypes(accessGrant);
 * ```
 *
 * @param vc The Access Grant/Request
 * @returns The VC types
 */
function getTypes(vc) {
    const results = [
        ...vc.match(namedNode(getId(vc)), TYPE, undefined, defaultGraph()),
    ].map((res) => res.object);
    const types = [];
    for (const result of results) {
        if (result.termType !== "NamedNode") {
            throw new AccessGrantError(`Expected every type to be a Named Node, but found [${result.value}] with term type [${result.termType}]`);
        }
        types.push(result.value);
        if (result.value in shorthand) {
            types.push(shorthand[result.value]);
        }
    }
    return types;
}
/**
 * Check whether a given Access Grant applies recursively to child resources or not.
 *
 * @example
 *
 * ```
 * const isInherited = getInherit(accessGrant);
 * ```
 *
 * @param vc The Access Grant/Request
 * @returns true if the Grant applies to contained resources, false otherwise.
 */
function getInherit(vc) {
    return !vc.has(quad(getConsent(vc), INHERIT, literal("false", XSD_BOOLEAN), defaultGraph()));
}
/**
 * Internal function. Deserializes a literal using the provided function.
 * If the literal cannot be deserialized as expected (e.g. an attempt to
 * deserialize a string as an integer), an error is thrown.
 *
 * @hidden
 */
function deserializeFields(vc, field, deserializer, type) {
    return Array.from(vc.match(getConsent(vc), namedNode(field.href), null, defaultGraph()))
        .map((q) => {
        if (q.object.termType !== "Literal") {
            throw new AccessGrantError(`Expected value object for predicate ${field.href} to be a literal, found ${q.object.termType}.`);
        }
        return q.object;
    })
        .map((object) => {
        const result = deserializer(object);
        if (result === undefined) {
            throw new AccessGrantError(`Failed to deserialize value ${object.value} for predicate ${field.href} as type ${type}.`);
        }
        return result;
    });
}
function deserializeField(vc, field, deserializer, type) {
    const result = deserializeFields(vc, field, deserializer, type);
    if (result.length > 1) {
        throw new AccessGrantError(`Expected one value for predicate ${field.href}, found many: ${result}`);
    }
    return result[0];
}
const xmlSchemaTypes = {
    boolean: namedNode("http://www.w3.org/2001/XMLSchema#boolean"),
    double: namedNode("http://www.w3.org/2001/XMLSchema#double"),
    integer: namedNode("http://www.w3.org/2001/XMLSchema#integer"),
    string: namedNode("http://www.w3.org/2001/XMLSchema#string"),
};
function deserializeBoolean(serialized) {
    if (!serialized.datatype.equals(xmlSchemaTypes.boolean)) {
        return undefined;
    }
    if (serialized.value === "true") {
        return true;
    }
    if (serialized.value === "false") {
        return false;
    }
    return undefined;
}
/**
 * Reads the custom boolean value with the provided name in the consent section of the provided Access Credential.
 * Throws on type mismatch, and returns `undefined` if no values are found.
 *
 * @example
 * ```
 * const accessRequest = await issueAccessRequest({...}, {
 *  ...,
 *  customFields: new Set([
 *     {
 *       key: new URL("https://example.org/ns/customBoolean"),
 *       value: true,
 *     },
 *   ]),
 * });
 * // b is true
 * const b = getCustomBoolean(accessRequest, new URL("https://example.org/ns/customBoolean"));
 * ```
 *
 * @param accessCredential The Access Credential (Access Grant or Access Request)
 * @returns the custom boolean field with the provided name
 * @since 3.2.0
 */
function getCustomBoolean(accessCredential, field) {
    return deserializeField(accessCredential, field, deserializeBoolean, "boolean");
}
function deserializeFloat(serialized) {
    if (!serialized.datatype.equals(xmlSchemaTypes.double)) {
        return undefined;
    }
    const val = Number.parseFloat(serialized.value);
    return Number.isNaN(val) ? undefined : val;
}
/**
 * Reads the custom float value with the provided name in the consent section of the provided Access Credential.
 * Throws on type mismatch, and returns `undefined` if no values are found.
 *
 * @example
 * ```
 * const accessRequest = await issueAccessRequest({...}, {
 *  ...,
 *  customFields: new Set([
 *     {
 *       key: new URL("https://example.org/ns/customFloat"),
 *       value: 1.1,
 *     },
 *   ]),
 * });
 * // f is 1.1
 * const f = getCustomFloat(accessRequest, new URL("https://example.org/ns/customFloat"));
 * ```
 *
 * @param accessCredential The Access Credential (Access Grant or Access Request)
 * @returns the custom float field with the provided name
 * @since 3.2.0
 */
function getCustomFloat(accessCredential, field) {
    return deserializeField(accessCredential, field, deserializeFloat, "float");
}
function deserializeInteger(serialized) {
    if (!serialized.datatype.equals(xmlSchemaTypes.integer)) {
        return undefined;
    }
    const val = Number.parseInt(serialized.value, 10);
    return Number.isNaN(val) ? undefined : val;
}
/**
 * Reads the custom integer value with the provided name in the consent section of the provided Access Credential.
 * Throws on type mismatch, and returns `undefined` if no values are found.
 *
 * @example
 * ```
 * const accessRequest = await issueAccessRequest({...}, {
 *  ...,
 *  customFields: new Set([
 *     {
 *       key: new URL("https://example.org/ns/customInteger"),
 *       value: 1,
 *     },
 *   ]),
 * });
 * // i is 1
 * const i = getCustomInteger(accessRequest, new URL("https://example.org/ns/customInteger"));
 * ```
 *
 * @param accessCredential The Access Credential (Access Grant or Access Request)
 * @returns the custom integer field with the provided name
 * @since 3.2.0
 */
function getCustomInteger(accessCredential, field) {
    return deserializeField(accessCredential, field, deserializeInteger, "integer");
}
/**
 * Reads the custom string value with the provided name in the consent section of the provided Access Credential.
 * Throws on type mismatch, and returns `undefined` if no values are found.
 *
 * @example
 * ```
 * const accessRequest = await issueAccessRequest({...}, {
 *  ...,
 *  customFields: new Set([
 *     {
 *       key: new URL("https://example.org/ns/customString"),
 *       value: "custom value",
 *     },
 *   ]),
 * });
 * // s is "custom value"
 * const s = getCustomString(accessRequest, new URL("https://example.org/ns/customString"));
 * ```
 *
 * @param accessCredential The Access Credential (Access Grant or Access Request)
 * @returns the custom string field with the provided name
 * @since 3.2.0
 */
function getCustomString(accessCredential, field) {
    return deserializeField(accessCredential, field, (str) => str.datatype.equals(xmlSchemaTypes.string) ? str.value : undefined, "string");
}
function castLiteral(lit) {
    if (lit.datatype.equals(xmlSchemaTypes.boolean)) {
        return deserializeBoolean(lit);
    }
    if (lit.datatype.equals(xmlSchemaTypes.double)) {
        return deserializeFloat(lit);
    }
    if (lit.datatype.equals(xmlSchemaTypes.integer)) {
        return deserializeInteger(lit);
    }
    if (lit.datatype.equals(xmlSchemaTypes.string)) {
        return lit.value;
    }
    throw new AccessGrantError(`Unsupported literal type ${lit.datatype.value}`);
}
const WELL_KNOWN_FIELDS = [
    gc.forPersonalData,
    gc.forPurpose,
    gc.isProvidedTo,
    gc.isProvidedToController,
    gc.isProvidedToPerson,
    gc.hasStatus,
    gc.isConsentForDataSubject,
    acl.mode,
    INHERIT,
];
/**
 * Reads all the custom fields in the consent section of the provided Access Credential.
 * An empty object will be returned if no custom fields are found.
 *
 * @example
 * ```
 * const accessRequest = await issueAccessRequest({...}, {
 *  ...,
 *  customFields: new Set([
 *     {
 *       key: new URL("https://example.org/ns/customString"),
 *       value: "custom value",
 *     },
 *     {
 *       key: new URL("https://example.org/ns/customInteger"),
 *       value: 1,
 *     },
 *   ]),
 * });
 * const customFields = getCustomFields(accessRequest);
 * // s is "custom value"
 * const s = customFields["https://example.org/ns/customString"];
 * // i is 1
 * const i = customFields["https://example.org/ns/custominteger"];
 * ```
 *
 * @param accessCredential The Access Credential (Access Grant or Access Request)
 * @returns an object keyed by the custom fields names, associated to their values.
 * @since 3.2.0
 */
function getCustomFields(accessCredential) {
    const consent = getConsent(accessCredential);
    return Array.from(accessCredential.match(consent, null, null, defaultGraph()))
        .filter(({ predicate, object }) => 
    // The Access Grant data model is known, so by elimination any unknown
    // field is a custom one.
    !WELL_KNOWN_FIELDS.some((wellKnown) => wellKnown.equals(predicate)) &&
        // Nested objects are not supported.
        object.termType === "Literal")
        .map(({ predicate, object }) => ({
        // The type assertion is okay, because we filter on the term type.
        [`${predicate.value}`]: castLiteral(object),
    }))
        .reduce((acc, cur) => {
        // There is a single key in the current object.
        const curKey = Object.keys(cur)[0];
        if (acc[curKey] !== undefined) {
            throw new AccessGrantError(`Expected single values for custom fields, found multiple for ${curKey}`);
        }
        return Object.assign(acc, cur);
    }, {});
}

export { getAccessModes, getConsent, getCustomBoolean, getCustomFields, getCustomFloat, getCustomInteger, getCustomString, getInbox, getInherit, getPurposes, getRequestor, getResourceOwner, getResources, getSingleObject, getTypes, isGConsentAccessGrant };
