import { CONTEXT_VC_W3C } from '../gConsent/constants.mjs';

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
const SUPPORTED_CONTEXTS = [
    "https://schema.inrupt.com/credentials/v1.jsonld",
    "https://schema.inrupt.com/credentials/v2.jsonld",
];
const SELF_HOSTED_URI_TEMPLATE = "https://{DOMAIN}/credentials/v1";
const instantiateSelfHosted = (domain) => SELF_HOSTED_URI_TEMPLATE.replace("{DOMAIN}", domain);
// The type assertion is required because TS doesn't validate the const array size vs the index.
const DEFAULT_CONTEXT = SUPPORTED_CONTEXTS.at(-1);
const WELL_KNOWN_CONFIG = "/.well-known/vc-configuration";
const providerCache = {};
/**
 * This internal function negotiates the most recent context supported by both the provider and the client.
 * It also caches the result in memory so that the VC provider configuration is only fetched once.
 * FIXME: use proper caching for eventual eviction.
 */
async function getIssuerContext(issuer) {
    if (providerCache[issuer.href] !== undefined) {
        return providerCache[issuer.href].context;
    }
    const configUrl = new URL(WELL_KNOWN_CONFIG, issuer);
    const response = await fetch(configUrl);
    try {
        const config = await response.json();
        const contexts = config["@context"];
        let providerCtx = contexts.find((ctx) => 
        // Typescript is too strict validating consts.
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        SUPPORTED_CONTEXTS.includes(ctx));
        const selfHosted = instantiateSelfHosted(issuer.hostname);
        // If no canonical context is being used, check for self-hosted (applicable to ESS 2.2).
        if (providerCtx === undefined && contexts.indexOf(selfHosted) !== -1) {
            // If the well-known config uses a self-hosted context, canonical v1 should be used.
            [providerCtx] = SUPPORTED_CONTEXTS;
        }
        if (providerCtx !== undefined) {
            providerCache[issuer.href] = { context: providerCtx };
        }
        return providerCtx;
    }
    catch (e) {
        // We don't want this issue to be swallowed silently.
        // eslint-disable-next-line no-console
        console.error(e);
    }
    return undefined;
}
const buildProviderContext = async (issuer) => [
    CONTEXT_VC_W3C,
    // If the issuer uses a context we don't support, default to the latest supported.
    (await getIssuerContext(issuer)) ?? DEFAULT_CONTEXT,
];

export { DEFAULT_CONTEXT, SUPPORTED_CONTEXTS, buildProviderContext, getIssuerContext };
