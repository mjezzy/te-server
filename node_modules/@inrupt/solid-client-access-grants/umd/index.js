(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('n3'), require('rdf-namespaces'), require('@inrupt/solid-client-vc'), require('@inrupt/solid-client-errors'), require('auth-header'), require('@inrupt/solid-client'), require('http-link-header')) :
  typeof define === 'function' && define.amd ? define(['exports', 'n3', 'rdf-namespaces', '@inrupt/solid-client-vc', '@inrupt/solid-client-errors', 'auth-header', '@inrupt/solid-client', 'http-link-header'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.SolidAccess = {}, global.n3, global.rdfNamespaces, global.solidClientVc, global.solidClientErrors, global.authHeader, global.solidClient, global.LinkHeader));
})(this, (function (exports, n3, rdfNamespaces, solidClientVc, solidClientErrors, authHeader, solidClient, LinkHeader) { 'use strict';

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const { namedNode: namedNode$4 } = n3.DataFactory;
  const GC = "https://w3id.org/GConsent#";
  const VC = "http://www.w3.org/ns/solid/vc#";
  const XSD = "http://www.w3.org/2001/XMLSchema#";
  const XSD_BOOLEAN = namedNode$4(`${XSD}boolean`);
  const TYPE = namedNode$4(rdfNamespaces.rdf.type);
  const solidVc = {
      SolidAccessRequest: namedNode$4(`${VC}SolidAccessRequest`),
      SolidAccessGrant: namedNode$4(`${VC}SolidAccessGrant`),
      SolidAccessDenial: namedNode$4(`${VC}SolidAccessDenial`),
  };
  const gc = {
      providedConsent: namedNode$4(`${GC}providedConsent`),
      hasConsent: namedNode$4(`${GC}hasConsent`),
      hasStatus: namedNode$4(`${GC}hasStatus`),
      isProvidedTo: namedNode$4(`${GC}isProvidedTo`),
      isProvidedToPerson: namedNode$4(`${GC}isProvidedToPerson`),
      isProvidedToController: namedNode$4(`${GC}isProvidedToController`),
      isConsentForDataSubject: namedNode$4(`${GC}isConsentForDataSubject`),
      forPurpose: namedNode$4(`${GC}forPurpose`),
      forPersonalData: namedNode$4(`${GC}forPersonalData`),
      ConsentStatusDenied: namedNode$4(`${GC}ConsentStatusDenied`),
      ConsentStatusExplicitlyGiven: namedNode$4(`${GC}ConsentStatusExplicitlyGiven`),
      ConsentStatusRequested: namedNode$4(`${GC}ConsentStatusRequested`),
  };
  const acl = {
      Read: namedNode$4(rdfNamespaces.acl.Read),
      Write: namedNode$4(rdfNamespaces.acl.Write),
      Append: namedNode$4(rdfNamespaces.acl.Append),
      mode: namedNode$4(rdfNamespaces.acl.mode),
  };
  const ldp = {
      inbox: namedNode$4("http://www.w3.org/ns/ldp#inbox"),
  };
  const INHERIT = namedNode$4("urn:uuid:71ab2f68-a68b-4452-b968-dd23e0570227");

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const SUPPORTED_CONTEXTS = [
      "https://schema.inrupt.com/credentials/v1.jsonld",
      "https://schema.inrupt.com/credentials/v2.jsonld",
  ];
  const SELF_HOSTED_URI_TEMPLATE = "https://{DOMAIN}/credentials/v1";
  const instantiateSelfHosted = (domain) => SELF_HOSTED_URI_TEMPLATE.replace("{DOMAIN}", domain);
  // The type assertion is required because TS doesn't validate the const array size vs the index.
  const DEFAULT_CONTEXT = SUPPORTED_CONTEXTS.at(-1);
  const WELL_KNOWN_CONFIG = "/.well-known/vc-configuration";
  const providerCache = {};
  /**
   * This internal function negotiates the most recent context supported by both the provider and the client.
   * It also caches the result in memory so that the VC provider configuration is only fetched once.
   * FIXME: use proper caching for eventual eviction.
   */
  async function getIssuerContext(issuer) {
      if (providerCache[issuer.href] !== undefined) {
          return providerCache[issuer.href].context;
      }
      const configUrl = new URL(WELL_KNOWN_CONFIG, issuer);
      const response = await fetch(configUrl);
      try {
          const config = await response.json();
          const contexts = config["@context"];
          let providerCtx = contexts.find((ctx) => 
          // Typescript is too strict validating consts.
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          SUPPORTED_CONTEXTS.includes(ctx));
          const selfHosted = instantiateSelfHosted(issuer.hostname);
          // If no canonical context is being used, check for self-hosted (applicable to ESS 2.2).
          if (providerCtx === undefined && contexts.indexOf(selfHosted) !== -1) {
              // If the well-known config uses a self-hosted context, canonical v1 should be used.
              [providerCtx] = SUPPORTED_CONTEXTS;
          }
          if (providerCtx !== undefined) {
              providerCache[issuer.href] = { context: providerCtx };
          }
          return providerCtx;
      }
      catch (e) {
          // We don't want this issue to be swallowed silently.
          // eslint-disable-next-line no-console
          console.error(e);
      }
      return undefined;
  }
  const buildProviderContext = async (issuer) => [
      CONTEXT_VC_W3C,
      // If the issuer uses a context we don't support, default to the latest supported.
      (await getIssuerContext(issuer)) ?? DEFAULT_CONTEXT,
  ];

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const GC_CONSENT_STATUS_DENIED_ABBREV = "ConsentStatusDenied";
  const GC_CONSENT_STATUS_EXPLICITLY_GIVEN_ABBREV = "ConsentStatusExplicitlyGiven";
  const GC_CONSENT_STATUS_REQUESTED_ABBREV = "ConsentStatusRequested";
  // TODO: Add dependency on generated vocabulary.
  const PIM_STORAGE = "http://www.w3.org/ns/pim/space#storage";
  // TODO: This is a temporary filler term, until we publish a definitive term for this.
  const PREFERRED_CONSENT_MANAGEMENT_UI = "http://inrupt.com/ns/ess#ConsentManagementUI";
  const CONTEXT_VC_W3C = "https://www.w3.org/2018/credentials/v1";
  const CREDENTIAL_TYPE_ACCESS_REQUEST = "SolidAccessRequest";
  const CREDENTIAL_TYPE_ACCESS_GRANT = "SolidAccessGrant";
  const CREDENTIAL_TYPE_ACCESS_DENIAL = "SolidAccessDenial";
  const CREDENTIAL_TYPE_BASE = "VerifiableCredential";
  const PRESENTATION_TYPE_BASE = "VerifiablePresentation";
  const ACCESS_CREDENTIAL_TYPE = new Set([
      CREDENTIAL_TYPE_ACCESS_REQUEST,
      CREDENTIAL_TYPE_ACCESS_GRANT,
      CREDENTIAL_TYPE_ACCESS_DENIAL,
      "vc:SolidAccessDenial",
  ]);
  const ACCESS_GRANT_STATUS = Object.freeze(new Set([
      gc.ConsentStatusDenied.value,
      gc.ConsentStatusExplicitlyGiven.value,
      GC_CONSENT_STATUS_DENIED_ABBREV,
      "gc:ConsentStatusDenied",
      "Consent:StatusDenied",
      GC_CONSENT_STATUS_EXPLICITLY_GIVEN_ABBREV,
  ]));
  const ACCESS_REQUEST_STATUS = Object.freeze(new Set([
      gc.ConsentStatusRequested.value,
      GC_CONSENT_STATUS_REQUESTED_ABBREV,
  ]));
  const ACCESS_STATUS = Object.freeze(new Set([...ACCESS_GRANT_STATUS, ...ACCESS_REQUEST_STATUS]));

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  // Implemented as isGConsentAccessGrant in src/common/getters as isGConsentAccessGrant
  function isAccessGrant(vc) {
      return (vc.credentialSubject.providedConsent !== undefined &&
          ACCESS_GRANT_STATUS.has(vc.credentialSubject.providedConsent.hasStatus) &&
          typeof vc.credentialSubject.providedConsent
              .isProvidedTo === "string");
  }
  /**
   * @deprecated This function checks structural assumptions about the JSON-LD presentation of the Access Grant,
   * which is not recommended. Use the RDFJS API that is now provided instead.
   */
  const CredentialIsAccessGrantGConsent = isAccessGrant;

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * @deprecated
   */
  function isAccessCredentialType(x) {
      return Array.isArray(x) && x.some((y) => ACCESS_CREDENTIAL_TYPE.has(y));
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * @deprecated
   */
  function isAccessGrantContext(x) {
      return Array.isArray(x) && x.includes(CONTEXT_VC_W3C);
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * @deprecated This function checks structural assumptions about the JSON-LD presentation of the VC,
   * which is not recommended. Use the RDFJS API that is now provided instead.
   */
  function isUnknownObject(x) {
      return x !== null && typeof x === "object";
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Superclass of errors thrown by the @inrupt/solid-client-access-grants library.
   */
  class AccessGrantError extends solidClientErrors.InruptClientError {
  }

  const { namedNode: namedNode$3, defaultGraph: defaultGraph$3, quad: quad$5, literal: literal$1 } = n3.DataFactory;
  function getSingleObject(vc, subject, predicate, type, required = true) {
      const results = [...vc.match(subject, predicate, null, defaultGraph$3())];
      if (results.length === 0 && !required) {
          return undefined;
      }
      if (results.length !== 1) {
          throw new AccessGrantError(`Expected exactly one result. Found ${results.length}.`);
      }
      const [{ object }] = results;
      const expectedTypes = type ? [type] : ["NamedNode", "BlankNode"];
      if (!expectedTypes.includes(object.termType)) {
          throw new AccessGrantError(`Expected [${object.value}] to be a ${expectedTypes.join(" or ")}. Found [${object.termType}]`);
      }
      return object;
  }
  /**
   * @internal
   */
  function getConsent(vc) {
      const credentialSubject = solidClientVc.getCredentialSubject(vc);
      const consents = [
          ...vc.match(credentialSubject, gc.providedConsent, null, defaultGraph$3()),
          ...vc.match(credentialSubject, gc.hasConsent, null, defaultGraph$3()),
      ];
      if (consents.length !== 1) {
          throw new AccessGrantError(`Expected exactly 1 consent value. Found ${consents.length}.`);
      }
      const [{ object }] = consents;
      if (object.termType !== "BlankNode" && object.termType !== "NamedNode") {
          throw new AccessGrantError(`Expected consent to be a Named Node or Blank Node, instead got [${object.termType}].`);
      }
      return object;
  }
  /**
   * Get the resources to which an Access Grant/Request applies.
   *
   * @example
   *
   * ```
   * const resources = getResources(accessGrant);
   * ```
   *
   * @param vc The Access Grant/Request
   * @returns The resources IRIs
   */
  function getResources(vc) {
      const resources = [];
      for (const { object } of vc.match(getConsent(vc), gc.forPersonalData, null, defaultGraph$3())) {
          if (object.termType !== "NamedNode") {
              throw new AccessGrantError(`Expected resource to be a Named Node. Instead got [${object.value}] with term type [${object.termType}]`);
          }
          resources.push(object.value);
      }
      return resources;
  }
  /**
   * Get the purposes for which an Access Grant/Request applies.
   *
   * @example
   *
   * ```
   * const purposes = getPurposes(accessGrant);
   * ```
   *
   * @param vc The Access Grant/Request
   * @returns The purpose IRIs
   */
  function getPurposes(vc) {
      const consent = getConsent(vc);
      const purposes = [];
      for (const { object } of vc.match(consent, gc.forPurpose, null, defaultGraph$3())) {
          if (object.termType !== "NamedNode") {
              throw new AccessGrantError(`Expected purpose to be Named Node. Instead got [${object.value}] with term type [${object.termType}]`);
          }
          purposes.push(object.value);
      }
      return purposes;
  }
  function isGConsentAccessGrant(vc) {
      const credentialSubject = solidClientVc.getCredentialSubject(vc);
      const providedConsent = getSingleObject(vc, credentialSubject, gc.providedConsent, undefined, false);
      if (!providedConsent)
          return false;
      const gcStatus = getSingleObject(vc, providedConsent, gc.hasStatus, undefined, false);
      return (gcStatus !== undefined &&
          (vc.has(quad$5(providedConsent, gc.hasStatus, gc.ConsentStatusDenied)) ||
              vc.has(quad$5(providedConsent, gc.hasStatus, gc.ConsentStatusExplicitlyGiven))) &&
          getSingleObject(vc, providedConsent, gc.isProvidedTo, undefined, false)
              ?.termType === "NamedNode");
  }
  function getResourceOwner(vc) {
      const credentialSubject = solidClientVc.getCredentialSubject(vc);
      if (isGConsentAccessGrant(vc)) {
          return credentialSubject.value;
      }
      return getSingleObject(vc, getSingleObject(vc, credentialSubject, gc.hasConsent), gc.isConsentForDataSubject, "NamedNode", false)?.value;
  }
  /**
   * Get the requestor asking for access to a resources with an Access Grant/Request.
   *
   * @example
   *
   * ```
   * const requestorWebId = getRequestor(accessGrant);
   * ```
   *
   * @param vc The Access Grant/Request
   * @returns The requestor WebID
   */
  function getRequestor(vc) {
      const credentialSubject = solidClientVc.getCredentialSubject(vc);
      const providedConsent = getSingleObject(vc, credentialSubject, gc.providedConsent, undefined, false);
      if (!providedConsent)
          return credentialSubject.value;
      const supportedPredicates = [
          gc.isProvidedTo,
          gc.isProvidedToPerson,
          gc.isProvidedToController,
      ];
      const candidateResults = [];
      supportedPredicates.forEach((predicate) => {
          const candidate = getSingleObject(vc, providedConsent, predicate, "NamedNode", false);
          if (candidate !== undefined) {
              candidateResults.push(candidate.value);
          }
      });
      if (candidateResults.length === 1) {
          return candidateResults[0];
      }
      if (candidateResults.length > 1) {
          throw new AccessGrantError(`Too many requestors found. Expected one, found ${candidateResults}`);
      }
      throw new AccessGrantError(`No requestor found.`);
  }
  /**
   * Get the inbox of the requestor of an Access Grant/Request.
   *
   * @example
   *
   * ```
   * const inbox = getInbox(accessGrant);
   * ```
   *
   * @param vc The Access Grant/Request
   * @returns The requestors inbox
   */
  function getInbox(vc) {
      try {
          return getSingleObject(vc, solidClientVc.getCredentialSubject(vc), ldp.inbox, "NamedNode")
              .value;
      }
      catch {
          return undefined;
      }
  }
  /**
   * Get the access modes granted to a resources via an Access Grant/Request.
   *
   * @example
   *
   * ```
   * const modes = getAccessModes(accessGrant);
   * ```
   *
   * @param vc The Access Grant/Request
   * @returns The access modes the grant recipient can exercise.
   */
  function getAccessModes(vc) {
      const consent = getConsent(vc);
      return {
          read: vc.has(quad$5(consent, acl.mode, acl.Read, defaultGraph$3())),
          write: vc.has(quad$5(consent, acl.mode, acl.Write, defaultGraph$3())),
          append: vc.has(quad$5(consent, acl.mode, acl.Append, defaultGraph$3())),
      };
  }
  const shorthand = {
      "http://www.w3.org/ns/solid/vc#SolidAccessRequest": "SolidAccessRequest",
      "http://www.w3.org/ns/solid/vc#SolidAccessDenial": "SolidAccessDenial",
      "http://www.w3.org/ns/solid/vc#SolidAccessGrant": "SolidAccessGrant",
      "https://www.w3.org/2018/credentials#VerifiableCredential": "VerifiableCredential",
      "https://www.w3.org/2018/credentials#VerifiablePresentation": "VerifiablePresentation",
  };
  /**
   * Get the VC types of an Access Grant/Request.
   *
   * @example
   *
   * ```
   * const types = getTypes(accessGrant);
   * ```
   *
   * @param vc The Access Grant/Request
   * @returns The VC types
   */
  function getTypes(vc) {
      const results = [
          ...vc.match(namedNode$3(solidClientVc.getId(vc)), TYPE, undefined, defaultGraph$3()),
      ].map((res) => res.object);
      const types = [];
      for (const result of results) {
          if (result.termType !== "NamedNode") {
              throw new AccessGrantError(`Expected every type to be a Named Node, but found [${result.value}] with term type [${result.termType}]`);
          }
          types.push(result.value);
          if (result.value in shorthand) {
              types.push(shorthand[result.value]);
          }
      }
      return types;
  }
  /**
   * Check whether a given Access Grant applies recursively to child resources or not.
   *
   * @example
   *
   * ```
   * const isInherited = getInherit(accessGrant);
   * ```
   *
   * @param vc The Access Grant/Request
   * @returns true if the Grant applies to contained resources, false otherwise.
   */
  function getInherit$1(vc) {
      return !vc.has(quad$5(getConsent(vc), INHERIT, literal$1("false", XSD_BOOLEAN), defaultGraph$3()));
  }
  /**
   * Internal function. Deserializes a literal using the provided function.
   * If the literal cannot be deserialized as expected (e.g. an attempt to
   * deserialize a string as an integer), an error is thrown.
   *
   * @hidden
   */
  function deserializeFields(vc, field, deserializer, type) {
      return Array.from(vc.match(getConsent(vc), namedNode$3(field.href), null, defaultGraph$3()))
          .map((q) => {
          if (q.object.termType !== "Literal") {
              throw new AccessGrantError(`Expected value object for predicate ${field.href} to be a literal, found ${q.object.termType}.`);
          }
          return q.object;
      })
          .map((object) => {
          const result = deserializer(object);
          if (result === undefined) {
              throw new AccessGrantError(`Failed to deserialize value ${object.value} for predicate ${field.href} as type ${type}.`);
          }
          return result;
      });
  }
  function deserializeField(vc, field, deserializer, type) {
      const result = deserializeFields(vc, field, deserializer, type);
      if (result.length > 1) {
          throw new AccessGrantError(`Expected one value for predicate ${field.href}, found many: ${result}`);
      }
      return result[0];
  }
  const xmlSchemaTypes = {
      boolean: namedNode$3("http://www.w3.org/2001/XMLSchema#boolean"),
      double: namedNode$3("http://www.w3.org/2001/XMLSchema#double"),
      integer: namedNode$3("http://www.w3.org/2001/XMLSchema#integer"),
      string: namedNode$3("http://www.w3.org/2001/XMLSchema#string"),
  };
  function deserializeBoolean(serialized) {
      if (!serialized.datatype.equals(xmlSchemaTypes.boolean)) {
          return undefined;
      }
      if (serialized.value === "true") {
          return true;
      }
      if (serialized.value === "false") {
          return false;
      }
      return undefined;
  }
  /**
   * Reads the custom boolean value with the provided name in the consent section of the provided Access Credential.
   * Throws on type mismatch, and returns `undefined` if no values are found.
   *
   * @example
   * ```
   * const accessRequest = await issueAccessRequest({...}, {
   *  ...,
   *  customFields: new Set([
   *     {
   *       key: new URL("https://example.org/ns/customBoolean"),
   *       value: true,
   *     },
   *   ]),
   * });
   * // b is true
   * const b = getCustomBoolean(accessRequest, new URL("https://example.org/ns/customBoolean"));
   * ```
   *
   * @param accessCredential The Access Credential (Access Grant or Access Request)
   * @returns the custom boolean field with the provided name
   * @since 3.2.0
   */
  function getCustomBoolean(accessCredential, field) {
      return deserializeField(accessCredential, field, deserializeBoolean, "boolean");
  }
  function deserializeFloat(serialized) {
      if (!serialized.datatype.equals(xmlSchemaTypes.double)) {
          return undefined;
      }
      const val = Number.parseFloat(serialized.value);
      return Number.isNaN(val) ? undefined : val;
  }
  /**
   * Reads the custom float value with the provided name in the consent section of the provided Access Credential.
   * Throws on type mismatch, and returns `undefined` if no values are found.
   *
   * @example
   * ```
   * const accessRequest = await issueAccessRequest({...}, {
   *  ...,
   *  customFields: new Set([
   *     {
   *       key: new URL("https://example.org/ns/customFloat"),
   *       value: 1.1,
   *     },
   *   ]),
   * });
   * // f is 1.1
   * const f = getCustomFloat(accessRequest, new URL("https://example.org/ns/customFloat"));
   * ```
   *
   * @param accessCredential The Access Credential (Access Grant or Access Request)
   * @returns the custom float field with the provided name
   * @since 3.2.0
   */
  function getCustomFloat(accessCredential, field) {
      return deserializeField(accessCredential, field, deserializeFloat, "float");
  }
  function deserializeInteger(serialized) {
      if (!serialized.datatype.equals(xmlSchemaTypes.integer)) {
          return undefined;
      }
      const val = Number.parseInt(serialized.value, 10);
      return Number.isNaN(val) ? undefined : val;
  }
  /**
   * Reads the custom integer value with the provided name in the consent section of the provided Access Credential.
   * Throws on type mismatch, and returns `undefined` if no values are found.
   *
   * @example
   * ```
   * const accessRequest = await issueAccessRequest({...}, {
   *  ...,
   *  customFields: new Set([
   *     {
   *       key: new URL("https://example.org/ns/customInteger"),
   *       value: 1,
   *     },
   *   ]),
   * });
   * // i is 1
   * const i = getCustomInteger(accessRequest, new URL("https://example.org/ns/customInteger"));
   * ```
   *
   * @param accessCredential The Access Credential (Access Grant or Access Request)
   * @returns the custom integer field with the provided name
   * @since 3.2.0
   */
  function getCustomInteger(accessCredential, field) {
      return deserializeField(accessCredential, field, deserializeInteger, "integer");
  }
  /**
   * Reads the custom string value with the provided name in the consent section of the provided Access Credential.
   * Throws on type mismatch, and returns `undefined` if no values are found.
   *
   * @example
   * ```
   * const accessRequest = await issueAccessRequest({...}, {
   *  ...,
   *  customFields: new Set([
   *     {
   *       key: new URL("https://example.org/ns/customString"),
   *       value: "custom value",
   *     },
   *   ]),
   * });
   * // s is "custom value"
   * const s = getCustomString(accessRequest, new URL("https://example.org/ns/customString"));
   * ```
   *
   * @param accessCredential The Access Credential (Access Grant or Access Request)
   * @returns the custom string field with the provided name
   * @since 3.2.0
   */
  function getCustomString(accessCredential, field) {
      return deserializeField(accessCredential, field, (str) => str.datatype.equals(xmlSchemaTypes.string) ? str.value : undefined, "string");
  }
  function castLiteral(lit) {
      if (lit.datatype.equals(xmlSchemaTypes.boolean)) {
          return deserializeBoolean(lit);
      }
      if (lit.datatype.equals(xmlSchemaTypes.double)) {
          return deserializeFloat(lit);
      }
      if (lit.datatype.equals(xmlSchemaTypes.integer)) {
          return deserializeInteger(lit);
      }
      if (lit.datatype.equals(xmlSchemaTypes.string)) {
          return lit.value;
      }
      throw new AccessGrantError(`Unsupported literal type ${lit.datatype.value}`);
  }
  const WELL_KNOWN_FIELDS$1 = [
      gc.forPersonalData,
      gc.forPurpose,
      gc.isProvidedTo,
      gc.isProvidedToController,
      gc.isProvidedToPerson,
      gc.hasStatus,
      gc.isConsentForDataSubject,
      acl.mode,
      INHERIT,
  ];
  /**
   * Reads all the custom fields in the consent section of the provided Access Credential.
   * An empty object will be returned if no custom fields are found.
   *
   * @example
   * ```
   * const accessRequest = await issueAccessRequest({...}, {
   *  ...,
   *  customFields: new Set([
   *     {
   *       key: new URL("https://example.org/ns/customString"),
   *       value: "custom value",
   *     },
   *     {
   *       key: new URL("https://example.org/ns/customInteger"),
   *       value: 1,
   *     },
   *   ]),
   * });
   * const customFields = getCustomFields(accessRequest);
   * // s is "custom value"
   * const s = customFields["https://example.org/ns/customString"];
   * // i is 1
   * const i = customFields["https://example.org/ns/custominteger"];
   * ```
   *
   * @param accessCredential The Access Credential (Access Grant or Access Request)
   * @returns an object keyed by the custom fields names, associated to their values.
   * @since 3.2.0
   */
  function getCustomFields(accessCredential) {
      const consent = getConsent(accessCredential);
      return Array.from(accessCredential.match(consent, null, null, defaultGraph$3()))
          .filter(({ predicate, object }) => 
      // The Access Grant data model is known, so by elimination any unknown
      // field is a custom one.
      !WELL_KNOWN_FIELDS$1.some((wellKnown) => wellKnown.equals(predicate)) &&
          // Nested objects are not supported.
          object.termType === "Literal")
          .map(({ predicate, object }) => ({
          // The type assertion is okay, because we filter on the term type.
          [`${predicate.value}`]: castLiteral(object),
      }))
          .reduce((acc, cur) => {
          // There is a single key in the current object.
          const curKey = Object.keys(cur)[0];
          if (acc[curKey] !== undefined) {
              throw new AccessGrantError(`Expected single values for custom fields, found multiple for ${curKey}`);
          }
          return Object.assign(acc, cur);
      }, {});
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const ACL_RESOURCE_ACCESS_MODE_APPEND = "http://www.w3.org/ns/auth/acl#Append";
  const ACL_RESOURCE_ACCESS_MODE_READ = "http://www.w3.org/ns/auth/acl#Read";
  const ACL_RESOURCE_ACCESS_MODE_WRITE = "http://www.w3.org/ns/auth/acl#Write";
  const ACL_RESOURCE_ACCESS_MODE_APPEND_ABBREV = "Append";
  const ACL_RESOURCE_ACCESS_MODE_READ_ABBREV = "Read";
  const ACL_RESOURCE_ACCESS_MODE_WRITE_ABBREV = "Write";
  const RESOURCE_ACCESS_MODE = new Set([
      ACL_RESOURCE_ACCESS_MODE_APPEND,
      ACL_RESOURCE_ACCESS_MODE_READ,
      ACL_RESOURCE_ACCESS_MODE_WRITE,
      // The following are linked to the previous through our JSON-LD context.
      ACL_RESOURCE_ACCESS_MODE_READ_ABBREV,
      ACL_RESOURCE_ACCESS_MODE_WRITE_ABBREV,
      ACL_RESOURCE_ACCESS_MODE_APPEND_ABBREV,
  ]);

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const { defaultGraph: defaultGraph$2 } = n3.DataFactory;
  function isResourceAccessModeArray(x) {
      return Array.isArray(x) && x.every((y) => RESOURCE_ACCESS_MODE.has(y));
  }
  function isGConsentStatus(x) {
      return typeof x === "string" && ACCESS_STATUS.has(x);
  }
  // TODO: Discuss a strongly typed UrlString guard (as a team).
  function isStringArray(x) {
      return Array.isArray(x) && x.every((y) => typeof y === "string");
  }
  /**
   * @deprecated This function checks structural assumptions about the JSON-LD presentation of the VC,
   * which is not recommended. Use the RDFJS API that is now provided instead.
   */
  function isGConsentAttributes(x) {
      return (isUnknownObject(x) &&
          isResourceAccessModeArray(x.mode) &&
          isGConsentStatus(x.hasStatus) &&
          isStringArray(x.forPersonalData));
  }
  function isRdfjsGConsentAttributes(dataset, 
  // eslint-disable-next-line camelcase
  consent) {
      // isResourceAccessModeArray
      const modeQuads = dataset.match(consent, acl.mode, null, defaultGraph$2());
      if (modeQuads.size === 0) {
          return false;
      }
      for (const { object: mode } of modeQuads) {
          if (![acl.Append, acl.Read, acl.Write].some((allowedMode) => allowedMode.equals(mode))) {
              return false;
          }
      }
      // isGConsentStatus
      const statuses = [
          ...dataset.match(consent, gc.hasStatus, null, defaultGraph$2()),
      ];
      if (statuses.length !== 1 ||
          ![
              gc.ConsentStatusDenied,
              gc.ConsentStatusExplicitlyGiven,
              gc.ConsentStatusRequested,
          ].some((e) => e.equals(statuses[0].object))) {
          return false;
      }
      const forPersonalData = dataset.match(consent, gc.forPersonalData, null, defaultGraph$2());
      if (forPersonalData.size === 0) {
          throw new AccessGrantError("No Personal Data specified for Access Grant");
      }
      for (const { object } of forPersonalData) {
          if (object.termType !== "NamedNode") {
              return false;
          }
      }
      return true;
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const { namedNode: namedNode$2, quad: quad$4 } = n3.DataFactory;
  /**
   * @deprecated This function checks structural assumptions about the JSON-LD presentation of the VC,
   * which is not recommended. Use the RDFJS API that is now provided instead.
   */
  function isBaseAccessVcBody(x) {
      return (isUnknownObject(x) &&
          isAccessGrantContext(x["@context"]) &&
          Array.isArray(x.type) &&
          isAccessCredentialType(x.type) &&
          isUnknownObject(x.credentialSubject) &&
          typeof x.credentialSubject.id === "string" &&
          (typeof x.credentialSubject.inbox === "string" ||
              typeof x.credentialSubject.inbox === "undefined") &&
          (x.issuanceDate !== undefined ? typeof x.issuanceDate === "string" : true));
  }
  function isRdfjsAccessVerifiableCredential(data, expectedTypes) {
      const s = namedNode$2(solidClientVc.getId(data));
      if (!expectedTypes.some((type) => data.has(quad$4(s, TYPE, type)))) {
          return false;
      }
      // getConsent and getIssuanceDate can error
      try {
          solidClientVc.getIssuanceDate(data);
          return isRdfjsGConsentAttributes(data, getConsent(data));
      }
      catch {
          return false;
      }
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * @deprecated Use RDFJS API instead.
   */
  function CredentialIsAccessGrantAny(vc) {
      return isBaseAccessVcBody(vc) && CredentialIsAccessGrantGConsent(vc);
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  async function getAccessEndpointForResource(resource) {
      // Explicitly makes an unauthenticated fetch to be sure to get the link to the
      // authorization server.
      const response = await fetch(resource);
      if (!response.headers.has("WWW-Authenticate")) {
          throw new AccessGrantError(`Expected a 401 error with a WWW-Authenticate header, got a [${response.status}: ${response.statusText}] response lacking the WWW-Authenticate header.`);
      }
      const authHeader$1 = response.headers.get("WWW-Authenticate");
      const authHeaderToken = authHeader.parse(authHeader$1);
      if (authHeaderToken.scheme !== "UMA") {
          throw new AccessGrantError(`Unsupported authorization scheme: [${authHeaderToken.scheme}]`);
      }
      const authorizationServerIri = authHeaderToken.params.as_uri;
      const wellKnownIri = new URL("/.well-known/uma2-configuration", authorizationServerIri);
      const rawDiscoveryDocument = await fetch(wellKnownIri.href);
      const discoveryDocument = await rawDiscoveryDocument.json();
      if (typeof discoveryDocument.verifiable_credential_issuer !== "string") {
          throw new AccessGrantError(`No access issuer listed for property [verifiable_credential_issuer] in [${JSON.stringify(discoveryDocument)}]`);
      }
      return discoveryDocument.verifiable_credential_issuer;
  }
  /**
   * Discovers the endpoint where access requests may be created for a given resource.
   *
   * @param resource The resource for which access may be requested.
   * @param options Optional properties to customise the access request behaviour.
   * @returns The URL of the access request server.
   * @since 0.4.0
   */
  async function getAccessApiEndpoint(resource, options = {}) {
      if (options.accessEndpoint !== undefined) {
          return options.accessEndpoint.toString();
      }
      try {
          return await getAccessEndpointForResource(resource.toString());
      }
      catch (e) {
          throw new AccessGrantError(`Couldn't figure out the Access Grant issuer from the resources: ${e}`);
      }
  }

  /**
   * Dynamically import solid-client-authn-browser so that
   * this library doesn't have a hard dependency.
   *
   * @returns fetch function
   */
  async function getSessionFetch(options) {
      if (options.fetch) {
          return options.fetch;
      }
      try {
          const { fetch: fetchFn } = await import(
          // @inrupt/solid-client-authn-browser is not in this code's direct dependencies,
          // we dynamically check whether it is in the caller's dependencies.
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          // eslint-disable-next-line import/no-unresolved
          '@inrupt/solid-client-authn-browser');
          return fetchFn;
      }
      catch {
          /* istanbul ignore next: @inrupt/solid-client-authn-browser is a devDependency, so this path is not hit in tests: */
          return fetch;
      }
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  async function getAccessManagementUiFromProfile(webId, options) {
      const result = {};
      let webIdDocument;
      try {
          webIdDocument = await solidClient.getSolidDataset(webId, {
              fetch: options.fetch,
          });
      }
      catch (e) {
          throw new AccessGrantError(`Cannot get the Access Management UI for ${webId}: ${e}.`);
      }
      const profile = solidClient.getThing(webIdDocument, webId);
      if (profile === null) {
          throw new AccessGrantError(`Cannot get the Access Management UI for ${webId}: the WebID cannot be dereferenced.`);
      }
      // TODO: rename constant & variable when a definitive term is published:
      const profileConsentUi = solidClient.getIri(profile, PREFERRED_CONSENT_MANAGEMENT_UI);
      if (profileConsentUi !== null) {
          result.accessEndpoint = profileConsentUi;
      }
      // If the profile document does not advertize for the access management UI, look for a storage root.
      const storage = solidClient.getIri(profile, PIM_STORAGE);
      if (storage !== null) {
          result.storage = storage;
      }
      return result;
  }
  /**
   * @since 0.4.0
   * @hidden
   */
  async function getAccessManagementUiFromWellKnown(storage, options) {
      if (storage === undefined) {
          return undefined;
      }
      const wellKnown = await solidClient.getWellKnownSolid(storage, {
          fetch: options.fetch,
      });
      if (solidClient.getThingAll(wellKnown, { acceptBlankNodes: true }).length === 0) {
          return undefined;
      }
      const wellKnownAccesstUi = solidClient.getIri(solidClient.getThingAll(wellKnown, { acceptBlankNodes: true })[0], PREFERRED_CONSENT_MANAGEMENT_UI);
      return wellKnownAccesstUi ?? undefined;
  }
  /**
   * Get the endpoint where the user prefers to be redirected when asked for access.
   * If the user does not specify an endpoint, this function attempts to discover the
   * default access UI recommended by their Pod provider.
   *
   * @param webId The WebID of the user asked for access.
   * @param options Optional properties to customise the access request behaviour.
   * @returns The URL where the user should be redirected, if discoverable.
   * @since 0.4.0
   */
  async function getAccessManagementUi(webId, options = {}) {
      const fetcher = await getSessionFetch(options);
      // TODO: Complete code coverage for URL argument
      const { accessEndpoint, storage } = await getAccessManagementUiFromProfile(webId.toString(), { fetch: fetcher });
      return (accessEndpoint ??
          getAccessManagementUiFromWellKnown(storage, { fetch: fetcher }));
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const { quad: quad$3, namedNode: namedNode$1 } = n3.DataFactory;
  async function getBaseAccess(vc, options, type, hasStatus) {
      if (type && !vc.has(quad$3(namedNode$1(solidClientVc.getId(vc)), TYPE, type))) {
          throw new AccessGrantError(`An error occurred when type checking the VC: Not of type [${type.value}].`);
      }
      if (hasStatus && !vc.has(quad$3(getConsent(vc), gc.hasStatus, hasStatus))) {
          throw new AccessGrantError(`An error occurred when type checking the VC: status not [${hasStatus.value}].`);
      }
      return vc;
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Internal function implementing redirection with some query parameters.
   *
   * @hidden
   */
  async function redirectWithParameters(target, queryParams, options) {
      const targetUrl = new URL(target);
      Object.entries(queryParams).forEach(([key, value]) => {
          targetUrl.searchParams.append(key, value);
      });
      if (options.redirectCallback !== undefined) {
          options.redirectCallback(targetUrl.href);
      }
      else {
          if (typeof window === "undefined") {
              throw new AccessGrantError("In a non-browser environment, a redirectCallback must be provided by the user.");
          }
          window.location.href = targetUrl.href;
      }
      // This redirects the user away from the app, so unless it throws an error,
      // there is no code that should run afterwards (since there is no "after" in
      // script's lifetime). Hence, this Promise never resolves:
      return new Promise(() => { });
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Auxiliary function to determine whether the candidateDataset implements the DatasetCore
   * interface.
   * @param candidateDataset the candidate to be checked.
   * @returns true if the candidate implements the DatasetCore interface, false otherwise.
   * @internal
   */
  function isDatasetCore(candidateDataset) {
      return typeof candidateDataset.add === "function";
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Converts a VC to a Dataset if possible. If VC is neither a URL, an RDFJS dataset,
   * nor a plain JSON VC, the returned value is undefined.
   * @param vc The input VC, which can be of types DatasetWithId, VerifiableCredential,
   * URL, UrlString or undefined.
   * @param options
   * @returns A promise that resolves to a DatasetWithId if the conversion is successful,
   * or undefined otherwise.
   */
  async function toVcDataset(vc, options) {
      // If the provided VC is already an RDFJS dataset, it can be returned directly.
      if (vc !== undefined && isDatasetCore(vc)) {
          return vc;
      }
      // Fetch the vc if a URL is provided.
      if (typeof vc === "string" || vc instanceof URL) {
          return solidClientVc.getVerifiableCredential(vc.toString(), {
              returnLegacyJsonld: false,
              skipValidation: true,
              fetch: options?.fetch,
          });
      }
      // Convert the provided plain JSON VC to an RDFJS dataset if appropriate.
      if (typeof vc === "object" && typeof vc.id === "string") {
          return solidClientVc.verifiableCredentialToDataset(vc, {
              includeVcProperties: true,
              requireId: true,
          });
      }
      // The provided argument is neither a URL, an RDFJS dataset, nor a plain JSON VC,
      // so we can't do anything with it.
      return undefined;
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Makes a request to the access server to verify the validity of a given Verifiable Credential.
   *
   * @param vc Either a VC, or a URL to a VC, to be verified.
   * @param options Optional properties to customise the request behaviour.
   * @returns An object containing checks, warnings, and errors.
   * @since 0.4.0
   */
  // TODO: Push verification further as this just checks it's a valid VC should we not type check the consent grant?
  async function isValidAccessGrant(vc, options = {}) {
      const fetcher = await getSessionFetch(options);
      const validVc = await toVcDataset(vc, options);
      if (validVc === undefined) {
          throw new AccessGrantError(`Invalid argument: expected either a VC URL or a RDFJS DatasetCore, received ${vc}`);
      }
      const vcObject = await getBaseAccess(validVc);
      // Discover the access endpoint from the resource part of the Access Grant.
      const verifierEndpoint = options.verificationEndpoint ??
          (await solidClientVc.getVerifiableCredentialApiConfiguration(solidClientVc.getIssuer(vcObject)))
              .verifierService;
      if (verifierEndpoint === undefined) {
          throw new AccessGrantError(`The VC service provider ${solidClientVc.getIssuer(vcObject)} does not advertize for a verifier service in its .well-known/vc-configuration document`);
      }
      const response = await fetcher(verifierEndpoint, {
          headers: {
              "Content-Type": "application/json",
          },
          method: "POST",
          body: JSON.stringify({
              verifiableCredential: vcObject,
          }),
      });
      // TODO: Add verification on the structure of the response
      return response.json();
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  // This file is used to create a 'common' API object from the top-level exports.

  var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getAccessModes: getAccessModes,
    getCredentialSubject: solidClientVc.getCredentialSubject,
    getCustomBoolean: getCustomBoolean,
    getCustomFields: getCustomFields,
    getCustomFloat: getCustomFloat,
    getCustomInteger: getCustomInteger,
    getCustomString: getCustomString,
    getExpirationDate: solidClientVc.getExpirationDate,
    getId: solidClientVc.getId,
    getInbox: getInbox,
    getInherit: getInherit$1,
    getIssuanceDate: solidClientVc.getIssuanceDate,
    getIssuer: solidClientVc.getIssuer,
    getPurposes: getPurposes,
    getRequestor: getRequestor,
    getResourceOwner: getResourceOwner,
    getResources: getResources,
    getTypes: getTypes,
    isValidAccessGrant: isValidAccessGrant
  });

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const REQUEST_VC_URL_PARAM_NAME = "requestVcUrl";
  const REDIRECT_URL_PARAM_NAME = "redirectUrl";
  async function discoverAccessManagementUi(options) {
      const authFetch = await getSessionFetch({ fetch: options.fetch });
      let accessManagementUi;
      if (options.resourceOwner) {
          accessManagementUi = await getAccessManagementUi(options.resourceOwner, {
              fetch: authFetch,
          });
      }
      else {
          accessManagementUi = await getAccessManagementUiFromWellKnown(options.resourceUrl, { fetch: authFetch });
      }
      return accessManagementUi ?? options.fallbackUi;
  }
  /**
   * Redirects the application to a resource owner's preferred access management
   * UI.
   *
   * @param accessRequestVc The VC containing the Access Request to a resource.
   * @param redirectUrl The URL where the user should be redirected back after
   * having granted access.
   * @param options If you are in a NodeJS environment, you must specify a
   * callback to handle the redirection.
   * @since 0.4.0
   */
  async function redirectToAccessManagementUi(accessRequestVc, redirectUrl, options = {}) {
      const fallbackUi = options.fallbackAccessManagementUi;
      const validVc = await toVcDataset(accessRequestVc, options);
      if (validVc === undefined) {
          throw new AccessGrantError(`Invalid argument: expected either a VC URL or a RDFJS DatasetCore, received ${accessRequestVc}`);
      }
      const requestVc = await getBaseAccess(validVc, {
          fetch: options.fetch,
      });
      const [resourceUrl] = getResources(requestVc);
      const accessManagementUi = await discoverAccessManagementUi({
          resourceUrl,
          resourceOwner: options.resourceOwner,
          fallbackUi,
          fetch: options.fetch,
      });
      if (accessManagementUi === undefined) {
          throw new AccessGrantError(`Cannot discover access management UI URL for [${resourceUrl}]${options.resourceOwner ? `, neither from [${options.resourceOwner}]` : ""}`);
      }
      return redirectWithParameters(accessManagementUi, {
          [`${REQUEST_VC_URL_PARAM_NAME}`]: encodeURI(requestVc.id),
          [`${REDIRECT_URL_PARAM_NAME}`]: encodeURI(typeof redirectUrl === "string" ? redirectUrl : redirectUrl.href),
      }, options);
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const { quad: quad$2, namedNode } = n3.DataFactory;
  /**
   * Revokes the given Verifiable Credential (VC). It supports revoking approved/denied Access Grants and Access Requests.
   *
   * This function is called by revokeAccessGrant and cancelAccessRequest.
   * Each of them call this function with the appropriate types parameter: [SolidAccessGrant, SolidAccessDenial] and
   * [SolidAccessRequest] respectively.
   * In both cases, index 0 of types array must contain either SolidAccessGrant or SolidAccessRequest type
   * for getBaseAccess to get the credential.
   * @internal
   */
  async function revokeAccessCredential(vc, types, options = {}) {
      const validVc = await toVcDataset(vc, options);
      if (validVc === undefined) {
          throw new AccessGrantError(`Invalid argument: expected either a VC URL or a RDFJS DatasetCore, received ${vc}`);
      }
      const credential = await getBaseAccess(validVc, options, types[0]);
      if (types.every((vcType) => !credential.has(quad$2(namedNode(solidClientVc.getId(credential)), TYPE, vcType)))) {
          throw new AccessGrantError(`An error occurred when type checking the VC: Not of type [${types.map((type) => type.value).join("] or [")}]`);
      }
      return solidClientVc.revokeVerifiableCredential(new URL("status", solidClientVc.getIssuer(credential)).href, solidClientVc.getId(credential), {
          fetch: await getSessionFetch(options),
      });
  }
  /**
   * Makes a request to the access server to revoke a given Verifiable Credential (VC).
   *
   * @param vc Either a VC, or a URL to a VC, to be revoked.
   * @param options Optional properties to customise the request behaviour.
   * @returns A void promise.
   * @since 0.4.0
   */
  async function revokeAccessGrant(vc, options = {}) {
      return revokeAccessCredential(vc, [solidVc.SolidAccessGrant, solidVc.SolidAccessDenial], options);
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Cancel a request for access to data (with explicit or implicit consent) before
   * the person being asked for access has replied.
   * This is equivalent to revoking a access grant.
   *
   * @param vc The access request, either in the form of a VC URL or a full-fledged VC.
   * @param options Optional properties to customise the access request behaviour.
   * @returns A void promise
   * @since 0.0.1
   */
  async function cancelAccessRequest(vc, options = {}) {
      return revokeAccessCredential(vc, [solidVc.SolidAccessRequest], options);
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * @deprecated This function is not required when using the RDFJS API
   */
  function accessToResourceAccessModeArray(desiredAccess) {
      const modes = [];
      if (desiredAccess.read === true) {
          modes.push(ACL_RESOURCE_ACCESS_MODE_READ);
      }
      if (desiredAccess.append === true) {
          modes.push(ACL_RESOURCE_ACCESS_MODE_APPEND);
      }
      if (desiredAccess.write === true) {
          modes.push(ACL_RESOURCE_ACCESS_MODE_WRITE);
      }
      return modes;
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * @deprecated This function checks structural assumptions about the JSON-LD presentation of the VC,
   * which is not recommended. Use the RDFJS API that is now provided instead.
   */
  function isBaseRequest(vc) {
      return vc.credentialSubject.hasConsent !== undefined;
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  function getGConsentAttributes(params, type) {
      const modes = accessToResourceAccessModeArray(params.access);
      const consentAttributes = {
          mode: modes,
          hasStatus: params.status,
          forPersonalData: params.resources,
      };
      if (params.purpose !== undefined) {
          consentAttributes.forPurpose = params.purpose;
      }
      if (params.inherit !== undefined) {
          consentAttributes.inherit = params.inherit;
      }
      if (type === "BaseGrantBody") {
          return {
              ...consentAttributes,
              isProvidedTo: params.requestor,
          };
      }
      return {
          ...consentAttributes,
          isConsentForDataSubject: params.resourceOwner,
      };
  }
  function getBaseBody(params, type) {
      const body = {
          "@context": [CONTEXT_VC_W3C, DEFAULT_CONTEXT],
          type: [
              type === "BaseGrantBody"
                  ? CREDENTIAL_TYPE_ACCESS_GRANT
                  : CREDENTIAL_TYPE_ACCESS_REQUEST,
          ],
          credentialSubject: {
              inbox: params.requestorInboxUrl,
          },
      };
      if (params.issuanceDate !== undefined) {
          body.issuanceDate = params.issuanceDate.toISOString();
      }
      if (params.expirationDate !== undefined) {
          body.expirationDate =
              params.expirationDate.toISOString();
      }
      if (type === "BaseGrantBody") {
          return {
              ...body,
              credentialSubject: {
                  ...body.credentialSubject,
                  providedConsent: getGConsentAttributes(params, type),
              },
          };
      }
      return {
          ...body,
          credentialSubject: {
              ...body.credentialSubject,
              hasConsent: getGConsentAttributes(params, type),
          },
      };
  }
  function getRequestBody(params, options) {
      const base = getBaseBody(params, "BaseRequestBody");
      if (typeof options?.customFields === "object") {
          Object.assign(base.credentialSubject.hasConsent, options.customFields);
      }
      return base;
  }
  function getGrantBody(params, options) {
      const base = getBaseBody(params, "BaseGrantBody");
      if (typeof options?.customFields === "object") {
          Object.assign(base.credentialSubject.providedConsent, options.customFields);
      }
      return base;
  }
  async function issueAccessVc(vcBody, options = {}) {
      const fetcher = await getSessionFetch(options);
      const hasConsent = isBaseRequest(vcBody);
      if (hasConsent &&
          vcBody.credentialSubject.hasConsent.forPersonalData.length <= 0) {
          throw new AccessGrantError("There are no resources in the access request");
      }
      else if (!hasConsent &&
          vcBody.credentialSubject.providedConsent.forPersonalData
              .length <= 0) {
          throw new AccessGrantError("There are no resources in the access grant");
      }
      const targetResourceIri = isBaseRequest(vcBody)
          ? vcBody.credentialSubject.hasConsent.forPersonalData[0]
          : vcBody.credentialSubject.providedConsent
              .forPersonalData[0];
      // TODO: find out if concatenating "issue" here is correct
      // It seems like the issuer endpoint should be discovered from the well-known direcly
      // And the access endpoint should be an object with one URI per service
      // (issuer service, verifier service... supposedly status and query and vc???)
      const provider = new URL(await getAccessApiEndpoint(targetResourceIri, options));
      const accessIssuerEndpoint = new URL("issue", provider);
      const issuedVc = await solidClientVc.issueVerifiableCredential(accessIssuerEndpoint.href, {
          "@context": await buildProviderContext(provider),
          ...vcBody.credentialSubject,
      }, {
          // All the required context is provided by buildProviderContext,
          // and vcBody contains a default context we don't want to include in the
          // result VC.
          "@context": [],
          type: vcBody.type,
          issuanceDate: vcBody.issuanceDate,
          expirationDate: vcBody.expirationDate,
      }, {
          fetch: fetcher,
          returnLegacyJsonld: options.returnLegacyJsonld,
          normalize: options.normalize,
      });
      return issuedVc;
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const WELL_KNOWN_FIELDS = [
      gc.forPersonalData,
      gc.forPurpose,
      gc.isProvidedTo,
      gc.isProvidedToController,
      gc.isProvidedToPerson,
      acl.mode,
      INHERIT,
  ];
  function isWellKnown(field) {
      return WELL_KNOWN_FIELDS.map((p) => p.value).includes(field.href);
  }
  /**
   * Internal function to collapse the user-provided custom fields into
   * a simple JSON object.
   *
   * @hidden
   */
  const toJson = (c = new Set()) => {
      return (Array.from(c)
          // Check that all the provided custom fields match the expected type,
          // and change the validated CustomField into a plain JSON object entry.
          .map((field) => {
          if (isWellKnown(field.key)) {
              throw new AccessGrantError(`${field.key.href} is a reserved field, and cannot be used as a custom field`);
          }
          if (typeof field.key !== "object") {
              throw new AccessGrantError(`All custom fields keys must be URL objects, found ${field.key}`);
          }
          if (!["string", "number", "boolean", "undefined"].includes(typeof field.value)) {
              throw new AccessGrantError(`All custom fields values must be literals, found ${JSON.stringify(field.value)} (of type ${typeof field.value})`);
          }
          return { [`${field.key.toString()}`]: field.value };
      })
          // Collapse all the JSON object entries into a single object.
          .reduce((acc, cur) => {
          // We know the current object has a single key.
          if (acc[Object.keys(cur)[0]] !== undefined) {
              // If the provided key already exists, the input is invalid.
              throw new AccessGrantError(`Each custom field key must be unique. Found multiple values for ${Object.keys(cur)[0]}`);
          }
          return Object.assign(acc, cur);
      }, {}));
  };

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * @deprecated This function checks structural assumptions about the JSON-LD presentation of the Access Request,
   * which is not recommended. Use the RDFJS API that is now provided instead.
   */
  function isRequestCredentialSubject(x) {
      return x.hasConsent !== undefined;
  }
  /**
   * @deprecated This function checks structural assumptions about the JSON-LD presentation of the Access Request,
   * which is not recommended. Use the RDFJS API that is now provided instead.
   */
  function isBaseAccessRequestVerifiableCredential(x) {
      return (isBaseAccessVcBody(x) &&
          isRequestCredentialSubject(x.credentialSubject) &&
          isGConsentAttributes(x.credentialSubject.hasConsent));
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const { quad: quad$1, defaultGraph: defaultGraph$1 } = n3.DataFactory;
  /**
   * @deprecated This function checks structural assumptions about the JSON-LD presentation of the Access Request,
   * which is not recommended. Use the RDFJS API that is now provided instead.
   */
  function isAccessRequest(x) {
      return (isBaseAccessRequestVerifiableCredential(x) &&
          ACCESS_REQUEST_STATUS.has(x.credentialSubject.hasConsent.hasStatus) &&
          x.credentialSubject.hasConsent.isConsentForDataSubject !== undefined &&
          typeof x.issuanceDate === "string");
  }
  function isRdfjsAccessRequest(dataset) {
      // We shouldn't ned this since getVerifiableCredential will be calling htis
      if (!isRdfjsAccessVerifiableCredential(dataset, [solidVc.SolidAccessRequest])) {
          return false;
      }
      try {
          // This will error if there is no issuance date and return false.
          // This is the behavior we want since Access Requests must have an issuance date
          solidClientVc.getIssuanceDate(dataset);
          const requestClaimSubject = getSingleObject(dataset, solidClientVc.getCredentialSubject(dataset), gc.hasConsent);
          return (dataset.has(quad$1(requestClaimSubject, gc.hasStatus, gc.ConsentStatusRequested)) &&
              dataset.match(requestClaimSubject, gc.isConsentForDataSubject, null, defaultGraph$1()).size === 1 &&
              isRdfjsGConsentAttributes(dataset, requestClaimSubject));
      }
      catch {
          return false;
      }
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Internal function. This is a stopgap until we have proper JSON-LD parsing.
   * It enforces the shape of the JSON returned by the issuer service, which may
   * vary while still serializing the same data.
   *
   * In particular, this transforms some literals into a one-value array.
   *
   * @hidden
   * @param accessRequest The grant returned by the VC issuer
   * @returns An equivalent JSON-LD document framed according to our typing.
   */
  function normalizeAccessRequest(accessRequest) {
      // Proper type checking is performed after normalization, so casting here is fine.
      const normalized = { ...accessRequest };
      if (!Array.isArray(normalized.credentialSubject.hasConsent.mode)) {
          normalized.credentialSubject.hasConsent.mode = [
              normalized.credentialSubject.hasConsent.mode,
          ];
      }
      if (!Array.isArray(normalized.credentialSubject.hasConsent.forPersonalData)) {
          normalized.credentialSubject.hasConsent.forPersonalData = [
              normalized.credentialSubject.hasConsent.forPersonalData,
          ];
      }
      if (typeof normalized.credentialSubject.hasConsent.inherit === "string") {
          // Literals are also interpreted based on the JSON-LD context, so a "true" value
          // could map to a "true"^^xsd:boolean, which is a boolean.
          normalized.credentialSubject.hasConsent.inherit =
              normalized.credentialSubject.hasConsent.inherit === "true";
      }
      // Cast back to the original type
      return normalized;
  }
  async function issueAccessRequest(params, options = {}) {
      const requestBody = getRequestBody({
          ...params,
          status: gc.ConsentStatusRequested.value,
      }, { customFields: toJson(options.customFields) });
      if (options.returnLegacyJsonld === false) {
          const accessRequest = await issueAccessVc(requestBody, {
              ...options,
              returnLegacyJsonld: false,
          });
          if (!isRdfjsAccessRequest(accessRequest)) {
              throw new AccessGrantError(`${JSON.stringify(accessRequest)} is not an Access Request`);
          }
          return accessRequest;
      }
      const accessRequest = await issueAccessVc(requestBody, {
          ...options,
          normalize: normalizeAccessRequest,
      });
      if (!isAccessRequest(accessRequest)) {
          throw new AccessGrantError(`${JSON.stringify(accessRequest)} is not an Access Request`);
      }
      return accessRequest;
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * @deprecated This function checks structural assumptions about the JSON-LD presentation of the Access Grant,
   * which is not recommended. Use the RDFJS API that is now provided instead.
   */
  function isGrantCredentialSubject(x) {
      return x.providedConsent !== undefined;
  }
  /**
   * @deprecated This function checks structural assumptions about the JSON-LD presentation of the Access Grant,
   * which is not recommended. Use the RDFJS API that is now provided instead.
   */
  function isBaseAccessGrantVerifiableCredential(x) {
      return (isBaseAccessVcBody(x) &&
          isGrantCredentialSubject(x.credentialSubject) &&
          isGConsentAttributes(x.credentialSubject.providedConsent));
  }
  function isRdfjsBaseAccessGrantVerifiableCredential(data) {
      return isRdfjsAccessVerifiableCredential(data, [
          solidVc.SolidAccessDenial,
          solidVc.SolidAccessGrant,
      ]);
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const { quad, literal, defaultGraph } = n3.DataFactory;
  const inheritQuad = (subject, inherit) => quad(subject, INHERIT, literal(inherit ? "true" : "false", XSD_BOOLEAN), defaultGraph());
  function getInherit(vc) {
      if (vc.has(inheritQuad(getConsent(vc), true))) {
          return true;
      }
      if (vc.has(inheritQuad(getConsent(vc), false))) {
          return false;
      }
      return undefined;
  }
  function initializeGrantParameters(requestVc, requestOverride) {
      const resultGrant = requestVc === undefined
          ? {
              ...requestOverride,
              customFields: toJson(requestOverride?.customFields),
              // The type assertion here reflects the constraints put in the overload of
              // approveAccessRequest.
          }
          : {
              requestor: requestOverride?.requestor ?? solidClientVc.getCredentialSubject(requestVc).value,
              access: requestOverride?.access ?? getAccessModes(requestVc),
              resources: requestOverride?.resources ?? getResources(requestVc),
              requestorInboxUrl: requestOverride?.requestorInboxUrl ?? getInbox(requestVc),
              issuanceDate: requestOverride?.issuanceDate ?? solidClientVc.getIssuanceDate(requestVc),
              purpose: requestOverride?.purpose ?? getPurposes(requestVc),
              expirationDate: requestOverride?.expirationDate ?? solidClientVc.getExpirationDate(requestVc),
              inherit: requestOverride?.inherit ?? getInherit(requestVc),
              customFields: requestOverride?.customFields !== undefined
                  ? {
                      ...getCustomFields(requestVc),
                      ...toJson(requestOverride?.customFields),
                  }
                  : getCustomFields(requestVc),
          };
      if (requestOverride?.expirationDate === null) {
          resultGrant.expirationDate = undefined;
      }
      return resultGrant;
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  // eslint-disable-next-line camelcase
  /**
   * Internal function. This is a stopgap until we have proper JSON-LD parsing.
   * It enforces the shape of the JSON returned by the issuer service, which may
   * vary while still serializing the same data.
   *
   * In particular, this transforms some literals into a one-value array.
   *
   * @hidden
   * @param accessGrant The grant returned by the VC issuer
   * @returns An equivalent JSON-LD document framed according to our typing.
   */
  function normalizeAccessGrant(accessGrant) {
      // Proper type checking is performed after normalization, so casting here is fine.
      const normalized = { ...accessGrant };
      if (normalized.credentialSubject.providedConsent === undefined) {
          throw new AccessGrantError(`[${normalized.id}] is not an Access Grant: missing field "credentialSubject.providedConsent".`);
      }
      if (!Array.isArray(normalized.credentialSubject.providedConsent.mode)) {
          normalized.credentialSubject.providedConsent.mode = [
              normalized.credentialSubject.providedConsent.mode,
          ];
      }
      if (!Array.isArray(normalized.credentialSubject.providedConsent.forPersonalData)) {
          normalized.credentialSubject.providedConsent.forPersonalData = [
              normalized.credentialSubject.providedConsent.forPersonalData,
          ];
      }
      if (typeof normalized.credentialSubject.providedConsent.inherit === "string") {
          // Literals are also interpreted based on the JSON-LD context, so a "true" value
          // could map to a "true"^^xsd:boolean, which is a boolean.
          normalized.credentialSubject.providedConsent.inherit =
              normalized.credentialSubject.providedConsent.inherit === "true";
      }
      // Cast back to the original type
      return normalized;
  }
  function getAccessModesFromAccessGrant(request) {
      const accessMode = {};
      const requestModes = request.credentialSubject.providedConsent.mode;
      accessMode.append = requestModes.includes(ACL_RESOURCE_ACCESS_MODE_APPEND);
      accessMode.read = requestModes.includes(ACL_RESOURCE_ACCESS_MODE_READ);
      accessMode.write = requestModes.includes(ACL_RESOURCE_ACCESS_MODE_WRITE);
      return accessMode;
  }
  async function addVcMatcher(targetResources, accessMode, options) {
      return Promise.all(targetResources.map(async (targetResource) => {
          // eslint-disable-next-line camelcase
          const resourceInfo = await solidClient.acp_ess_2.getResourceInfoWithAcr(targetResource, options);
          // eslint-disable-next-line camelcase
          if (!solidClient.acp_ess_2.hasAccessibleAcr(resourceInfo)) {
              throw new AccessGrantError("The current user does not have access to the resource's Access Control Resource. Either they have insufficiant credentials, or the resource is not controlled using ACP. In either case, an Access Grant cannot be issued.");
          }
          // eslint-disable-next-line camelcase
          const updatedResource = solidClient.acp_ess_2.setVcAccess(resourceInfo, accessMode, {
              inherit: options?.inherit ?? true,
          });
          // eslint-disable-next-line camelcase
          return solidClient.acp_ess_2.saveAcrFor(updatedResource, options);
      }));
  }
  async function approveAccessRequest(requestVc, requestOverride, options = {}) {
      const internalOptions = {
          ...options,
          fetch: options.fetch ?? (await getSessionFetch(options)),
          updateAcr: options.updateAcr ?? true,
      };
      const validVc = await toVcDataset(requestVc, options);
      const internalGrantOptions = initializeGrantParameters(typeof validVc !== "undefined"
          ? await getBaseAccess(validVc, options, solidVc.SolidAccessRequest, gc.ConsentStatusRequested)
          : undefined, requestOverride);
      const grantBody = getGrantBody({
          access: internalGrantOptions.access,
          requestor: internalGrantOptions.requestor,
          resources: internalGrantOptions.resources,
          requestorInboxUrl: internalGrantOptions.requestorInboxUrl,
          purpose: internalGrantOptions.purpose,
          issuanceDate: internalGrantOptions.issuanceDate,
          expirationDate: internalGrantOptions.expirationDate ?? undefined,
          status: gc.ConsentStatusExplicitlyGiven.value,
          inherit: internalGrantOptions.inherit,
      }, { customFields: internalGrantOptions.customFields });
      const grantedAccess = getAccessModesFromAccessGrant(grantBody);
      if (internalOptions.updateAcr === true) {
          await addVcMatcher(grantBody.credentialSubject.providedConsent.forPersonalData, grantedAccess, internalOptions);
      }
      const accessGrant = await issueAccessVc(grantBody, {
          ...internalOptions,
          returnLegacyJsonld: options.returnLegacyJsonld,
          normalize: normalizeAccessGrant,
      });
      if (options.returnLegacyJsonld !== false
          ? !isBaseAccessGrantVerifiableCredential(accessGrant) ||
              !isAccessGrant(accessGrant)
          : !isRdfjsBaseAccessGrantVerifiableCredential(accessGrant)) {
          throw new AccessGrantError(`Unexpected response when approving Access Request, the result is not an Access Grant: ${JSON.stringify(accessGrant)}`);
      }
      return accessGrant;
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  async function denyAccessRequest(vc, options) {
      const validVc = await toVcDataset(vc, options);
      if (validVc === undefined) {
          throw new AccessGrantError(`Invalid argument: expected either a VC URL or a RDFJS DatasetCore, received ${vc}`);
      }
      const baseVc = await getBaseAccess(validVc, options ?? {}, solidVc.SolidAccessRequest);
      const internalOptions = initializeGrantParameters(baseVc);
      const denialBody = getGrantBody({
          access: internalOptions.access,
          requestor: internalOptions.requestor,
          resources: internalOptions.resources,
          requestorInboxUrl: internalOptions.requestorInboxUrl,
          status: gc.ConsentStatusExplicitlyGiven.value,
          purpose: internalOptions.purpose,
          // denyAccessRequest doesn't take an override, so the expiration date
          // cannot be null.
          expirationDate: internalOptions.expirationDate,
      });
      denialBody.type = [CREDENTIAL_TYPE_ACCESS_DENIAL];
      denialBody.credentialSubject.providedConsent.hasStatus =
          gc.ConsentStatusDenied.value;
      return issueAccessVc(denialBody, {
          ...options,
          normalize: normalizeAccessGrant,
      });
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Retrieve the Access Grant associated to the given URL.
   *
   * @param accessGrantVcUrl The URL of an access grant, with or without consent.
   * @param options Optional properties to customise the request behaviour.
   * @returns The Verifiable Credential associated to the given IRI, if it is an access grant. Throws otherwise.
   * @since 0.4.0
   */
  async function getAccessGrant(accessGrantVcUrl, options) {
      const vcUrl = typeof accessGrantVcUrl === "string"
          ? accessGrantVcUrl
          : accessGrantVcUrl.href;
      if (options?.returnLegacyJsonld === false) {
          const data = await solidClientVc.getVerifiableCredential(vcUrl, {
              fetch: options?.fetch,
              returnLegacyJsonld: false,
          });
          if (!isRdfjsBaseAccessGrantVerifiableCredential(data) ||
              !isGConsentAccessGrant(data)) {
              throw new AccessGrantError(`Unexpected response when resolving [${vcUrl}], the result is not an Access Grant: ${JSON.stringify(data, null, 2)}`);
          }
          return data;
      }
      const data = await solidClientVc.getVerifiableCredential(vcUrl, {
          fetch: options?.fetch,
          normalize: normalizeAccessGrant,
      });
      if (!isBaseAccessGrantVerifiableCredential(data) || !isAccessGrant(data)) {
          throw new AccessGrantError(`Unexpected response when resolving [${vcUrl}], the result is not an Access Grant: ${JSON.stringify(data)}`);
      }
      return data;
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  // Iteratively build the list of ancestor containers from the breakdown of the
  // resource path: for resource https://pod.example/foo/bar/baz, we'll want the result
  // to be ["https://pod.example/", "https://pod.example/foo/", "https://pod.example/foo/bar/", https://pod.example/foo/bar/baz].
  const getAncestorUrls = (resourceUrl) => {
      // Splitting on / will result in the first element being empty (since the path
      // starts with /) and in the last element being the target resource name.
      const ancestorNames = resourceUrl.pathname
          .split("/")
          .slice(1, resourceUrl.pathname.endsWith("/") ? -2 : -1);
      return ancestorNames.reduce((ancestors, curName) => {
          // Add each intermediary container to ancestorPaths
          const currentPath = `${ancestors[0]}${curName}/`;
          return [new URL(currentPath, resourceUrl.origin), ...ancestors];
      }, 
      // The storage origin may be the storage root (it happens not to be the case in ESS).
      // The target resource should also be included.
      [new URL("/", resourceUrl.origin), resourceUrl]);
  };
  async function getAccessGrantAll(params, options = {}) {
      if (!params.resource && !options.accessEndpoint) {
          throw new AccessGrantError("resource and accessEndpoint cannot both be undefined");
      }
      const sessionFetch = await getSessionFetch(options);
      // TODO: Fix access API endpoint retrieval (should include all the different API endpoints)
      const baseUrl = new URL(options.accessEndpoint ??
          (await getAccessApiEndpoint(params.resource, options)));
      const queryEndpoint = new URL("derive", baseUrl);
      const ancestorUrls = params.resource
          ? getAncestorUrls(typeof params.resource === "string"
              ? new URL(params.resource)
              : params.resource)
          : [undefined];
      const specifiedModes = accessToResourceAccessModeArray(params.access ?? {});
      const type = [CREDENTIAL_TYPE_BASE];
      const statusShorthand = params.status ?? "granted";
      if (statusShorthand === "granted") {
          type.push(CREDENTIAL_TYPE_ACCESS_GRANT);
      }
      else if (statusShorthand === "denied") {
          type.push(CREDENTIAL_TYPE_ACCESS_DENIAL);
      }
      const vcShapes = await Promise.all(ancestorUrls.map(async (url) => ({
          "@context": (await buildProviderContext(baseUrl)),
          type,
          credentialSubject: {
              providedConsent: {
                  hasStatus: {
                      granted: gc.ConsentStatusExplicitlyGiven.value,
                      denied: gc.ConsentStatusDenied.value,
                      all: undefined,
                  }[statusShorthand],
                  forPersonalData: url ? [url.href] : undefined,
                  forPurpose: params.purpose,
                  isProvidedTo: params.requestor,
                  mode: specifiedModes.length > 0 ? specifiedModes : undefined,
              },
          },
      })));
      let result;
      if (options.returnLegacyJsonld === false) {
          // TODO: Fix up the type of accepted arguments (this function should allow deep partial)
          result = (await Promise.all(vcShapes.map((vcShape) => solidClientVc.getVerifiableCredentialAllFromShape(queryEndpoint.href, vcShape, {
              fetch: sessionFetch,
              includeExpiredVc: options.includeExpired,
              returnLegacyJsonld: false,
          }))))
              // getVerifiableCredentialAllFromShape returns a list, so the previous map
              // should be flattened to have all the candidate grants in a non-nested list.
              .flat()
              .filter((vc) => isRdfjsBaseAccessGrantVerifiableCredential(vc));
      }
      else {
          result = (await Promise.all(vcShapes.map((vcShape) => solidClientVc.getVerifiableCredentialAllFromShape(queryEndpoint.href, vcShape, {
              fetch: sessionFetch,
              includeExpiredVc: options.includeExpired,
              normalize: normalizeAccessGrant,
          }))))
              // getVerifiableCredentialAllFromShape returns a list, so the previous map
              // should be flattened to have all the candidate grants in a non-nested list.
              .flat()
              .filter((vc) => isBaseAccessGrantVerifiableCredential(vc) && isAccessGrant(vc));
      }
      // Explicitly non-recursive grants are filtered out, except if they apply
      // directly to the target resource (in the case a resource is used as a
      // filtering criteria for getAccessGrantAll).
      return result.filter((vc) => getInherit$1(vc) !== false ||
          params.resource === undefined ||
          getResources(vc).includes(params.resource.toString()));
  }

  /**
   * Fetch the Access Request from the given URL.
   *
   * @param url The URL of the Access Request.
   * @param options Optional properties to customise the behaviour:
   * - fetch: an authenticated fetch function. If not provided, the default session
   * from @inrupt/solid-client-authn-browser will be used if available.
   * @returns An Access Request.
   * @since 2.4.0
   * @deprecated Use RDFJS API instead of relying on the JSON structure by setting `returnLegacyJsonld` to false
   */
  async function getAccessRequest(url, options = {}) {
      if (options?.returnLegacyJsonld === false) {
          const accessRequest = await solidClientVc.getVerifiableCredential(url.toString(), {
              fetch: options.fetch ?? (await getSessionFetch(options)),
              returnLegacyJsonld: false,
          });
          if (!isRdfjsAccessRequest(accessRequest)) {
              throw new AccessGrantError(`${JSON.stringify(accessRequest)} is not an Access Request`);
          }
          return accessRequest;
      }
      const accessRequest = await solidClientVc.getVerifiableCredential(url.toString(), {
          fetch: options.fetch ?? (await getSessionFetch(options)),
          normalize: normalizeAccessRequest,
      });
      if (!isAccessRequest(accessRequest)) {
          throw new AccessGrantError(`${JSON.stringify(accessRequest, null, 2)} is not an Access Request`);
      }
      return accessRequest;
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  function getSearchParam(url, param) {
      const value = url.searchParams.get(param);
      if (value === null) {
          throw new AccessGrantError(`The provided redirect URL [${url.toString()}] is missing the expected [${param}] query parameter`);
      }
      return value;
  }
  async function getAccessRequestFromRedirectUrl(redirectUrl, options) {
      const redirectUrlObj = typeof redirectUrl === "string" ? new URL(redirectUrl) : redirectUrl;
      // Get the URL where the requestor expects the user to be redirected with
      // the grant.
      const requestorRedirectUrl = getSearchParam(redirectUrlObj, REDIRECT_URL_PARAM_NAME);
      // Get the Access Request IRI.
      const accessRequestIri = getSearchParam(redirectUrlObj, REQUEST_VC_URL_PARAM_NAME);
      return {
          accessRequest: await getAccessRequest(accessRequestIri, options),
          requestorRedirectUrl,
      };
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const GRANT_VC_URL_PARAM_NAME = "accessGrantUrl";
  /**
   * Redirect the user to the client which requested Access to a Resource. The Access
   * Grant is sent as part of the redirect.
   *
   * @param accessGrantVcId The ID of the Access Grant VC, which should be a URL
   * @param redirectUrl The URL where the client requesting access expects the
   * user to be redirected
   * @param options If you are in a NodeJS environment, you must specify a
   * callback to handle the redirection.
   * @returns A never resolving promise: the user is expected to be redirected away
   * from the page by this call, so no code should be expected to run in that context
   * after the redirect.
   * @since 0.5.0
   */
  async function redirectToRequestor(accessGrantVcId, redirectUrl, options = {}) {
      return redirectWithParameters(redirectUrl.toString(), {
          [`${GRANT_VC_URL_PARAM_NAME}`]: encodeURI(accessGrantVcId.toString()),
      }, options);
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  async function getAccessGrantFromRedirectUrl(redirectUrl, options = {}) {
      const redirectUrlObj = typeof redirectUrl === "string" ? new URL(redirectUrl) : redirectUrl;
      const accessGrantIri = redirectUrlObj.searchParams.get(GRANT_VC_URL_PARAM_NAME);
      if (accessGrantIri === null) {
          throw new AccessGrantError(`The provided redirect URL [${redirectUrl}] is missing the expected [${GRANT_VC_URL_PARAM_NAME}] query parameter`);
      }
      return getAccessGrant(accessGrantIri, options);
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Supported durations for Access Credential filtering.
   */
  const DURATION = {
      ONE_DAY: "P1D",
      ONE_WEEK: "P7D",
      ONE_MONTH: "P1M",
      THREE_MONTHS: "P3M",
  };
  const FILTER_ELEMENTS = [
      "fromAgent",
      "issuedWithin",
      "page",
      "pageSize",
      "purpose",
      "resource",
      "revokedWithin",
      "status",
      "toAgent",
      "type",
  ];
  // The type assertion is okay in the context of the type guard.
  const isSupportedFilterElement = (x) => FILTER_ELEMENTS.includes(x);
  const PAGING_RELS = ["first", "last", "prev", "next"];
  function toCredentialFilter(url) {
      const filter = {};
      url.searchParams.forEach((value, key) => {
          if (isSupportedFilterElement(key)) {
              Object.assign(filter, { [`${key}`]: value });
          }
      });
      return filter;
  }
  async function parseQueryResponse(responseJson) {
      // The type assertion here is immediately checked.
      const candidate = responseJson;
      if (candidate.items === undefined || !Array.isArray(candidate.items)) {
          throw new AccessGrantError(`Unexpected query response, no 'items' array found in ${JSON.stringify(responseJson)}`);
      }
      return Promise.all(candidate.items.map((vc) => {
          return solidClientVc.verifiableCredentialToDataset(vc);
      })).catch((error) => {
          throw new AccessGrantError(`Unexpected query response, parsing the content of the 'items' array failed.`, {
              cause: error,
          });
      });
  }
  async function toCredentialResult(response) {
      const result = { items: [] };
      const linkHeader = response.headers.get("Link");
      if (linkHeader !== null) {
          const parsedLinks = LinkHeader.parse(linkHeader);
          PAGING_RELS.forEach((rel) => {
              const link = parsedLinks.get("rel", rel);
              if (link.length > 1) {
                  throw Error(`Unexpected response, found more than one [${rel}] Link headers.`);
              }
              if (link.length === 0) {
                  return;
              }
              // The type assertion here relies on the consistency of the server
              // response with the client request, which must be AccessRequestFilter | AccessGrantFilter.
              result[rel] = toCredentialFilter(new URL(link[0].uri));
          });
      }
      result.items = await parseQueryResponse(await response.json());
      return result;
  }
  function toQueryUrl(endpoint, filter) {
      const result = new URL(endpoint);
      Object.entries(filter).forEach(([key, value]) => {
          if (isSupportedFilterElement(key)) {
              result.searchParams.append(key, value.toString());
          }
      });
      return result;
  }
  /**
   * Query for Access Credential (Access Requests, Access Grants or Access Denials) based on a given filter,
   * and get a page of results.
   *
   * @param filter The query filter
   * @param options Query options
   * @returns a paginated set of Access Credentials matching the given filter
   * @since 3.2.0
   *
   * @example
   * ```
   *  // Get the first results page.
   *  const activeGrantsWithinDay = await query(
   *       {
   *         type: "SolidAccessGrant",
   *         status: "Active",
   *         issuedWithin: DURATION.ONE_DAY,
   *       },
   *       {
   *         fetch: session.fetch,
   *         queryEndpoint: config.queryEndpoint,
   *       },
   *     );
   * // Get the next results page.
   * const activeGrantsWithinDay2 = await query(
   *       activeGrantsWithinDay.next,
   *       {
   *         fetch: session.fetch,
   *         queryEndpoint: config.queryEndpoint,
   *       },
   *     );
   * ```
   */
  async function query(filter, options) {
      const queryUrl = toQueryUrl(options.queryEndpoint, filter);
      const response = await options.fetch(queryUrl);
      if (!response.ok) {
          throw solidClientErrors.handleErrorResponse(response, await response.text(), `The query endpoint [${queryUrl}] returned an error`);
      }
      return toCredentialResult(response);
  }
  /**
   * Query for Access Credential (Access Requests, Access Grants or Access Denials) based on a given filter,
   * and traverses all of the result pages.
   *
   * @param filter The query filter
   * @param options Query options
   * @returns an async iterator going through the result pages
   * @since 3.2.0
   *
   * @example
   * ```
   *  const pages = paginatedQuery(
   *     {},
   *     {
   *       fetch: session.fetch,
   *       queryEndpoint: new URL("https://vc.example.org/query"),
   *     },
   *   );
   *   for await (const page of pages) {
   *     // do something with the result page.
   *   }
   * ```
   */
  async function* paginatedQuery(filter, options) {
      let page = await query(filter, options);
      while (page.next !== undefined) {
          yield page;
          // This is a generator, so we don't want to go through
          // all the pages at once with a Promise.all approach.
          // eslint-disable-next-line no-await-in-loop
          page = await query(page.next, options);
      }
      // Return the last page.
      yield page;
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //

  var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DURATION: DURATION,
    GRANT_VC_URL_PARAM_NAME: GRANT_VC_URL_PARAM_NAME,
    REDIRECT_URL_PARAM_NAME: REDIRECT_URL_PARAM_NAME,
    REQUEST_VC_URL_PARAM_NAME: REQUEST_VC_URL_PARAM_NAME,
    approveAccessRequest: approveAccessRequest,
    cancelAccessRequest: cancelAccessRequest,
    denyAccessRequest: denyAccessRequest,
    getAccessApiEndpoint: getAccessApiEndpoint,
    getAccessGrant: getAccessGrant,
    getAccessGrantAll: getAccessGrantAll,
    getAccessGrantFromRedirectUrl: getAccessGrantFromRedirectUrl,
    getAccessManagementUi: getAccessManagementUi,
    getAccessRequest: getAccessRequest,
    getAccessRequestFromRedirectUrl: getAccessRequestFromRedirectUrl,
    issueAccessRequest: issueAccessRequest,
    paginatedQuery: paginatedQuery,
    query: query,
    redirectToAccessManagementUi: redirectToAccessManagementUi,
    redirectToRequestor: redirectToRequestor,
    revokeAccessGrant: revokeAccessGrant
  });

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Superclass of errors thrown in the context of using an Access Grant to get access to a resource.
   */
  class UmaError extends solidClientErrors.InruptClientError {
  }

  const WWW_AUTH_HEADER = "www-authenticate";
  const VC_CLAIM_TOKEN_TYPE = "https://www.w3.org/TR/vc-data-model/#json-ld";
  const UMA_GRANT_TYPE = "urn:ietf:params:oauth:grant-type:uma-ticket";
  const UMA_CONFIG_PATH = "/.well-known/uma2-configuration";
  const NO_WWW_AUTH_HEADER_ERROR = "No www-authentication header found in response headers; UMA cannot proceed. Refer to your network requests for details.";
  const NO_WWW_AUTH_HEADER_UMA_TICKET_ERROR = 'www-authentication header in response headers did not include "ticket"; UMA cannot proceed. Refer to your network requests for details.';
  const NO_WWW_AUTH_HEADER_UMA_IRI_ERROR = 'www-authentication header in response headers did not include "as_uri"; UMA cannot proceed. Refer to your network requests for details.';
  const NO_ACCESS_TOKEN_RETURNED = "No access token was returned during the UMA exchange flow. Refer to your network requests for details.";
  const UMA_TICKET_REGEX = /ticket="([^"]+)"/;
  const UMA_IRI_REGEX = /as_uri="([^"]+)"/;
  /**
   * @hidden This is just an internal utility function to parse the ticket value out of the www-authenticate header.
   */
  function parseUMAAuthTicket(header) {
      const matches = UMA_TICKET_REGEX.exec(header);
      return matches ? matches[1] : null;
  }
  /**
   * @hidden This is just an internal utility function to parse the as_uri value out of the www-authenticate header.
   */
  function parseUMAAuthIri(header) {
      const matches = UMA_IRI_REGEX.exec(header);
      return matches ? matches[1] : null;
  }
  /**
   * @hidden This is just an internal utility function to get the UMA configuration from .well-known.
   */
  async function getUmaConfiguration(authIri) {
      const configurationUrl = new URL(UMA_CONFIG_PATH, authIri).href;
      const response = await fetch(configurationUrl);
      return response.json().catch((e) => {
          throw new UmaError(`Parsing the UMA configuration found at ${configurationUrl} failed with the following error: ${e.toString()}`);
      });
  }
  /**
   * @hidden Internal utility isomorphic function to encode in base64.
   */
  function isomorphicBtoa(stringToEncode) {
      if (typeof window === "object") {
          return btoa(stringToEncode);
      }
      return Buffer.from(stringToEncode).toString("base64");
  }
  /**
   * @hidden This is just an internal utility function to exchange a VC and ticket for an auth token.
   */
  async function exchangeTicketForAccessToken(tokenEndpoint, accessGrant, authTicket, authFetch) {
      const credentialPresentation = {
          // This is the presentation context, so only the W3C context is required.
          "@context": [CONTEXT_VC_W3C],
          type: [PRESENTATION_TYPE_BASE],
          verifiableCredential: [accessGrant],
      };
      const response = await authFetch(tokenEndpoint, {
          method: "POST",
          headers: {
              "Content-Type": "application/x-www-form-urlencoded",
          },
          body: new URLSearchParams({
              claim_token: isomorphicBtoa(JSON.stringify(credentialPresentation)),
              claim_token_format: VC_CLAIM_TOKEN_TYPE,
              grant_type: UMA_GRANT_TYPE,
              ticket: authTicket,
          }).toString(),
      });
      try {
          const data = await response.json();
          return data.access_token || null;
      }
      catch {
          // An error being thrown here means that the response body doesn't parse as JSON.
          return null;
      }
  }
  /**
   * @hidden This is just an internal utility function to bind a fetch function to the UMA auth token.
   */
  function boundFetch(accessToken) {
      // Explicitly use a named function such that it appears in stacktraces
      return function authenticatedFetch(url, init) {
          return fetch(url, {
              ...init,
              headers: {
                  ...(init?.headers || {}),
                  authorization: `Bearer ${accessToken}`,
              },
          });
      };
  }
  /**
   * Builds a WHATWG Fetch compatible function issuing authenticated requests
   * based on an Access Grant VC. The obtained fetch function authentication will
   * only be valid for the resources included in the Access Grant.
   *
   * Note that providing an authenticated `fetch` as an option is mandatory for
   * the resulting fetch to be valid. The input fetch should be authenticated to
   * the requestor's Solid-OIDC provider.
   *
   * @param resourceIri One of the resources from the Access Grant.
   * @param accessGrant The Verifiable Credential proving that the requestor has
   * been granted access to the target resource.
   * @param options Additional fetch options, allowing you to override the
   * `fetch()` implementation
   * @returns A Promise resolving to a WHATWG Fetch compatible function matching
   * the standard signature. The obtained fetch function will override any
   * provided `Authentication` header with authentication information obtained
   * thanks to the provided VC.
   * @since 0.4.0
   */
  async function fetchWithVc(
  // Why UrlString instead of UrlString | Url? Because Urls aren't compatible
  // with the fetch return type.
  resourceIri, accessGrant, options) {
      // Use an authenticated session to fetch the resource so that we can parse
      // its headers to find the UMA endpoint information and ticket
      const response = await fetch(resourceIri);
      const { headers } = response;
      const wwwAuthentication = headers.get(WWW_AUTH_HEADER);
      if (!wwwAuthentication) {
          throw new UmaError(NO_WWW_AUTH_HEADER_ERROR);
      }
      const authTicket = parseUMAAuthTicket(wwwAuthentication);
      const authIri = parseUMAAuthIri(wwwAuthentication);
      if (!authTicket) {
          throw new UmaError(NO_WWW_AUTH_HEADER_UMA_TICKET_ERROR);
      }
      if (!authIri) {
          throw new UmaError(NO_WWW_AUTH_HEADER_UMA_IRI_ERROR);
      }
      const umaConfiguration = await getUmaConfiguration(authIri);
      const tokenEndpoint = umaConfiguration.token_endpoint;
      const accessToken = await exchangeTicketForAccessToken(tokenEndpoint, accessGrant, authTicket, options?.fetch ?? fetch);
      if (!accessToken) {
          throw new UmaError(NO_ACCESS_TOKEN_RETURNED);
      }
      return boundFetch(accessToken);
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Retrieve a File from a Solid Pod using an Access Grant to prove the caller is
   * authorized to access the target resource.
   *
   * @see [@inrupt/solid-client's
   * getFile](https://docs.inrupt.com/developer-tools/api/javascript/solid-client/modules/resource_file.html#getfile)
   *
   * @param resourceUrl The URL of the target resource.
   * @param accessGrant The Access Grant VC proving the caller is authorized.
   * @param options Optional properties to customise the request behaviour.
   * @returns A promise that resolves to a File if successful, and that rejects
   * otherwise.
   * @since 0.4.0
   */
  async function getFile(resourceUrl, accessGrant, options) {
      const authenticatedFetch = await fetchWithVc(resourceUrl, accessGrant, options);
      return await solidClient.getFile(resourceUrl, {
          ...options,
          fetch: authenticatedFetch,
      });
  }
  /**
   * Overwrites the file using an Access Grant to prove the caller is authorized
   * to write to the given resource URL.
   *
   * ```{note} This function does not support saving a file if the file does not
   * yet exist, unlike its `@inrupt/solid-client` counterpart. To save a new file
   * in a container, you should use [saveFileInContainer](#savefileincontainer)
   * instead.
   * ```
   *
   * @see [@inrupt/solid-client's
   * overwriteFile](https://docs.inrupt.com/developer-tools/api/javascript/solid-client/modules/resource_file.html#overwritefile)
   *
   * @param resourceUrl The URL where the file is located.
   * @param file The file to be written.
   * @param accessGrant The Access Grant VC proving the caller is authorized.
   * @param options Optional properties to customise the request behaviour, or
   * override the Content-Type of the file.
   * @returns A promise that resolves to a File if successful, and that rejects
   * otherwise.
   * @since 1.1.0
   */
  async function overwriteFile(resourceUrl, file, accessGrant, options) {
      const authenticatedFetch = await fetchWithVc(resourceUrl, accessGrant, options);
      return await solidClient.overwriteFile(resourceUrl, file, {
          ...options,
          fetch: authenticatedFetch,
      });
  }
  /**
   * Saves a file in the given container URL using an Access Grant to prove the caller is
   * authorized to save a file in the given container.
   *
   * @see [@inrupt/solid-client's
   * saveFileInContainer](https://docs.inrupt.com/developer-tools/api/javascript/solid-client/modules/resource_file.html#savefileincontainer)
   *
   * @param containerUrl The container URL where the file is to be saved.
   * @param file The file to be written.
   * @param accessGrant The Access Grant VC proving the caller is authorized.
   * @param options Optional properties to customise the request behaviour, or override the Content-Type of the file.
   * @returns A promise that resolves to a File if successful, and that rejects
   * otherwise.
   * @since 1.1.0
   */
  async function saveFileInContainer(containerUrl, file, accessGrant, options) {
      const authenticatedFetch = await fetchWithVc(containerUrl, accessGrant, options);
      return await solidClient.saveFileInContainer(containerUrl, file, {
          ...options,
          fetch: authenticatedFetch,
      });
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Create an empty Container inside the Container at the given URL.
   *
   * Throws an error if creating the Container failed, e.g. because the current user does not have
   * permissions to. In particular, the Access Grant being used should at least append access to the target Container.
   *
   * The Container in which to create the new Container should itself already exist.
   *
   * This function is primarily useful if the current user does not have access to change existing files in
   * a Container, but is allowed to add new files; in other words, they have Append, but not Write
   * access to a Container. This is useful in situations where someone wants to allow others to,
   * for example, send notifications to their Pod, but not to view or delete existing notifications.
   * You can pass a suggestion for the new Resource's name, but the server may decide to give it
   * another name  for example, if a Resource with that name already exists inside the given
   * Container.
   * If the user does have access to write directly to a given location, createContainerAt
   * will do the job just fine, and does not require the parent Container to exist in advance.
   *
   * @param containerUrl URL of the Container in which the empty Container is to
   * be created.
   * @param accessGrant The Access Grant that would allow the Agent/Application to
   * perform this operation.
   * @param options Optional parameter:
   * - `options.fetch`: An alternative `fetch` function to make the HTTP request,
   *   compatible with the browser-native [fetch API](https://developer.mozilla.org/docs/Web/API/WindowOrWorkerGlobalScope/fetch#parameters).
   * @returns A promise that resolves to a SolidDataset with ResourceInfo if
   * successful, and that rejects otherwise.
   * @since 2.1.0
   */
  async function createContainerInContainer(containerUrl, accessGrant, options) {
      const authenticatedFetch = await fetchWithVc(containerUrl, accessGrant, options);
      return await solidClient.createContainerInContainer(containerUrl, {
          ...options,
          fetch: authenticatedFetch,
      });
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Delete a File from a Solid Pod using an Access Grant to prove the caller
   * is authorized to overwrite the target file.
   *
   * @see [@inrupt/solid-client's
   * deleteSolidDataset](https://docs.inrupt.com/developer-tools/api/javascript/solid-client/modules/resource_solidDataset.html#deletefile)
   *
   * @param fileUrl The URL of the target file.
   * @param accessGrant The Access Grant VC proving the caller is authorized.
   * @param options Optional properties to customise the request behaviour.
   * @returns A promise that resolves to a SolidDataset if successful, and that
   * rejects otherwise.
   * @since 2.4.0
   */
  async function deleteFile(fileUrl, accessGrant, options) {
      const authenticatedFetch = await fetchWithVc(fileUrl, accessGrant, options);
      return await solidClient.deleteFile(fileUrl, {
          ...options,
          fetch: authenticatedFetch,
      });
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Delete a Dataset from a Solid Pod using an Access Grant to prove the caller
   * is authorized to overwrite the target dataset.
   *
   * @see [@inrupt/solid-client's
   * deleteSolidDataset](https://docs.inrupt.com/developer-tools/api/javascript/solid-client/modules/resource_solidDataset.html#deletesoliddataset)
   *
   * @param datasetUrl The URL of the target dataset.
   * @param accessGrant The Access Grant VC proving the caller is authorized.
   * @param options Optional properties to customise the request behaviour.
   * @returns A promise that resolves to a SolidDataset if successful, and that
   * rejects otherwise.
   * @since 2.4.0
   */
  async function deleteSolidDataset(datasetUrl, accessGrant, options) {
      const authenticatedFetch = await fetchWithVc(datasetUrl, accessGrant, options);
      return await solidClient.deleteSolidDataset(datasetUrl, {
          ...options,
          fetch: authenticatedFetch,
      });
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Retrieve a Dataset from a Solid Pod using an Access Grant to prove the caller
   * is authorized to access the target dataset.
   *
   * @see [@inrupt/solid-client's
   * getSolidDataset](https://docs.inrupt.com/developer-tools/api/javascript/solid-client/modules/resource_solidDataset.html#getsoliddataset)
   *
   * @param datasetUrl The URL of the target dataset.
   * @param accessGrant The Access Grant VC proving the caller is authorized.
   * @param options Optional properties to customise the request behaviour.
   * @returns A promise that resolves to a SolidDataset if successful, and that
   * rejects otherwise.
   * @since 0.4.0
   */
  async function getSolidDataset(datasetUrl, accessGrant, options) {
      const authenticatedFetch = await fetchWithVc(datasetUrl, accessGrant, options);
      return await solidClient.getSolidDataset(datasetUrl, {
          ...options,
          fetch: authenticatedFetch,
      });
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Saves a Dataset in a Solid Pod using an Access Grant to prove the caller is
   * authorized to write or append to the dataset at the given dataset URL.
   *
   * ```{note}
   * This function does not support saving a dataset if the
   * dataset does not yet exist, unlike its `@inrupt/solid-client`
   * counterpart.
   * ```
   *
   * @see [@inrupt/solid-client's
   * saveSolidDatasetAt](https://docs.inrupt.com/developer-tools/api/javascript/solid-client/modules/resource_solidDataset.html#savesoliddatasetat)
   *
   * @param datasetUrl The URL of the dataset to save.
   * @param accessGrant The Access Grant VC proving the caller is authorized.
   * @param options Optional properties to customise the request behaviour.
   * @returns A promise that resolves to a SolidDataset if successful, and that
   * rejects otherwise.
   * @since 0.4.0
   */
  async function saveSolidDatasetAt(datasetUrl, solidDataset, accessGrant, options) {
      const authenticatedFetch = await fetchWithVc(datasetUrl, accessGrant, options);
      return await solidClient.saveSolidDatasetAt(datasetUrl, solidDataset, {
          ...options,
          fetch: authenticatedFetch,
      });
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Given a SolidDataset, store it in a Solid Pod as a new Resource inside a Container.
   *
   * The Container at the given URL should already exist; if it does not, you can initialise it first
   * using createContainerAt, or directly save the SolidDataset at the desired location using
   * {@link resource.saveSolidDatasetAt}.
   *
   * This function is primarily useful if the current user has not been granted
   * access to change existing files in a Container, but is allowed to add new
   * files; in other words, they have been granted Append, but not Write access to
   * a Container. This is useful in situations where someone wants to allow others
   * to, for example, send notifications to their Pod, but not to view or delete
   * existing notifications. You can pass a suggestion for the new Resource's
   * name, but the server may decide to give it another name  for example, if a
   * Resource with that name already exists inside the given Container. If the
   * user does have access to write directly to a given location,
   * {@link resource.saveSolidDatasetAt} will do the job just fine, and does not require the
   * parent Container to exist in advance.
   *
   * @see [@inrupt/solid-client's
   * saveSolidDatasetInContainer](https://docs.inrupt.com/developer-tools/api/javascript/solid-client/modules/resource_solidDataset.html#savesoliddatasetincontainer)
   *
   *
   * @param containerUrl URL of the Container in which to create a new Resource.
   * @param solidDataset The SolidDataset to save to a new Resource in the given Container.
   * @param accessGrant The Access Grant that would allow the Agent/Application to perform this operation.
   * @param options Optional parameter `options.fetch`: An alternative `fetch` function to make the HTTP request, compatible with the browser-native [fetch API](https://developer.mozilla.org/docs/Web/API/WindowOrWorkerGlobalScope/fetch#parameters).
   * @returns A Promise resolving to a SolidDataset containing the saved data. The Promise rejects if the save failed.
   * @since 2.1.0
   */
  async function saveSolidDatasetInContainer(containerUrl, solidDataset, accessGrant, options) {
      const authenticatedFetch = await fetchWithVc(containerUrl, accessGrant, options);
      return await solidClient.saveSolidDatasetInContainer(containerUrl, solidDataset, {
          ...options,
          fetch: authenticatedFetch,
      });
  }

  Object.defineProperty(exports, "getCredentialSubject", {
    enumerable: true,
    get: function () { return solidClientVc.getCredentialSubject; }
  });
  Object.defineProperty(exports, "getExpirationDate", {
    enumerable: true,
    get: function () { return solidClientVc.getExpirationDate; }
  });
  Object.defineProperty(exports, "getId", {
    enumerable: true,
    get: function () { return solidClientVc.getId; }
  });
  Object.defineProperty(exports, "getIssuanceDate", {
    enumerable: true,
    get: function () { return solidClientVc.getIssuanceDate; }
  });
  Object.defineProperty(exports, "getIssuer", {
    enumerable: true,
    get: function () { return solidClientVc.getIssuer; }
  });
  exports.CredentialIsAccessGrantAny = CredentialIsAccessGrantAny;
  exports.DURATION = DURATION;
  exports.GRANT_VC_URL_PARAM_NAME = GRANT_VC_URL_PARAM_NAME;
  exports.REDIRECT_URL_PARAM_NAME = REDIRECT_URL_PARAM_NAME;
  exports.REQUEST_VC_URL_PARAM_NAME = REQUEST_VC_URL_PARAM_NAME;
  exports.approveAccessRequest = approveAccessRequest;
  exports.cancelAccessRequest = cancelAccessRequest;
  exports.common = index$1;
  exports.createContainerInContainer = createContainerInContainer;
  exports.deleteFile = deleteFile;
  exports.deleteSolidDataset = deleteSolidDataset;
  exports.denyAccessRequest = denyAccessRequest;
  exports.fetchWithVc = fetchWithVc;
  exports.gConsent = index;
  exports.getAccessApiEndpoint = getAccessApiEndpoint;
  exports.getAccessGrant = getAccessGrant;
  exports.getAccessGrantAll = getAccessGrantAll;
  exports.getAccessGrantFromRedirectUrl = getAccessGrantFromRedirectUrl;
  exports.getAccessManagementUi = getAccessManagementUi;
  exports.getAccessModes = getAccessModes;
  exports.getAccessRequest = getAccessRequest;
  exports.getAccessRequestFromRedirectUrl = getAccessRequestFromRedirectUrl;
  exports.getCustomBoolean = getCustomBoolean;
  exports.getCustomFields = getCustomFields;
  exports.getCustomFloat = getCustomFloat;
  exports.getCustomInteger = getCustomInteger;
  exports.getCustomString = getCustomString;
  exports.getFile = getFile;
  exports.getInbox = getInbox;
  exports.getInherit = getInherit$1;
  exports.getPurposes = getPurposes;
  exports.getRequestor = getRequestor;
  exports.getResourceOwner = getResourceOwner;
  exports.getResources = getResources;
  exports.getSolidDataset = getSolidDataset;
  exports.getTypes = getTypes;
  exports.isValidAccessGrant = isValidAccessGrant;
  exports.issueAccessRequest = issueAccessRequest;
  exports.overwriteFile = overwriteFile;
  exports.paginatedQuery = paginatedQuery;
  exports.query = query;
  exports.redirectToAccessManagementUi = redirectToAccessManagementUi;
  exports.redirectToRequestor = redirectToRequestor;
  exports.revokeAccessGrant = revokeAccessGrant;
  exports.saveFileInContainer = saveFileInContainer;
  exports.saveSolidDatasetAt = saveSolidDatasetAt;
  exports.saveSolidDatasetInContainer = saveSolidDatasetInContainer;

}));
